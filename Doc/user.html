<HTML>
<HEAD>
<TITLE>VoiceCode User Manual</TITLE>
</HEAD>

<BODY   BGCOLOR="#ffffff">


<MAP NAME="banner_top">
    <AREA SHAPE="rect" COORDS="588,14,620,40" HREF="http://www.iit.nrc.ca/english.html">
    <AREA SHAPE="rect" COORDS="538,14,583,37" HREF="http://www.nrc.ca/corporate/english/">
    <AREA SHAPE="rect" COORDS="86,4,421,37" HREF="http://www.iit.nrc.ca/II_public/index.html">
</MAP>
<table cellpadding="5" cellspacing="0" border="0" width="100%">
<tr>
<td valign="bottom" align="left">
<IMG SRC="http://www.iit.nrc.ca/II_public/images/banner_top.jpg" width="620" height="37" alt="II Group Banner" USEMAP="#banner_top"
ISMAP border="0"><BR><IMG SRC="http://www.iit.nrc.ca/II_public/images/banner_voicecode.gif" width="230" height="50" alt="II VoiceGrip"></td>
</tr>
<tr><td>&nbsp;</td></tr>
</table>


<H1><FONT COLOR="#400080">VoiceCode User manual</FONT></H1>

<LI><A HREF="#intro">Introduction</A>
<LI><A HREF="#using">Using VoiceCode</A>
   <UL>
   <LI><A HREF="#simulation">Starting the Editor Simulator</A></H2>
   <LI><A HREF="#CSCs">Context Sensitive Commands (CSCs)</A>
   <LI><A HREF="#LSAs">Language Specific Aliases (LSAs)</A>
   <LI><A HREF="#symbols">Dictating symbols</A>
   <LI><A HREF="#NavigateByPseudoSymbol">NavigateByPseudoCode</A>
   <LI><A HREF="#shellCommands">The command prompt field</A>
   <LI><A HREF="#commandIndex">VoiceCode commands</A>
   </UL>
<LI><A HREF="#config">Configuring VoiceCode</A>
   <UL>
   <LI><A HREF="#configFile">The VoiceCode configuration file</A>
   <LI><A HREF="#debugConfig">Debugging the configuration file</A>
   <LI><A HREF="#customeCSCs">Customising CSCs</A>
   <LI><A HREF="#customLSAs">Customising LSAs</A>
   <LI><A HREF="#abbreviations">Adding/modifying abbreviations</A>
   <LI><A HREF="#symbolFormatting">Changing symbol formatting conventions</A>
   <LI><A HREF="#VCODE_NOSPEECH">Running the Editor Simulator  without NatSpeak</A>
   </UL>
<LI><A HREF="#trouble">Trouble shooting</A>
   <UL>
   <LI><A HREF="#micButton">No mic button in Editor Simulator</A>
   <LI><A HREF="#accuracy">Accuracy is poor</A>
   <LI><A HREF="#notResponding">VoiceCode doesn't hear me</A>
   <LI><A HREF="#noTranslation">VoiceCode doesn't translate pseudo-code to native code</A>
   <LI><A HREF="#undefinedUser">ERROR: <EM>SR user 'VoiceCode' not defined.</EM></A>
   <LI><A HREF="#SRERR_VALUEOUTOFRANGE">When I start VoiceCode, I get <EM>SRERR_VALUEOUTOFRANGE error</EM></A>
   </UL>


<h2>User Doc TODO</h2>
<UL>
   <LI>picture of edsim
   <LI>weblint it
</UL>

<HR>

<h2><A NAME="intro">Introduction</A></h2>

NOTE THIS IS SERIOUSLY OUT OF DATE

This document is the user documentation for the Alpha-minus-1 version of
VoiceCode. This version is not usable and was released just to allow
people to get a feel for the current status of the project. In
particular, this version can only be used with a simple editor which
we have developped for the purpose of testing and demoing the
system. We call this the <EM>Editor Simulator</EM> because that's all it
really is (at the time of writing, it didn't even support saving of
files). We plan to have the system connected to a real editor (jEdit
or Emacs) within a few months, but for now the <EM>Editor
Simulator</EM> should allow you to get a feel for what VoiceCode
currently supports.


<P>

The basic idea in VoiceCode is to allow programmers to speak in pseudo-code, instead of struggling to dictate statements exactly as they are written (to get a better feel for what that means, I suggest you look at the following 
<A HREF="http://ii2.ai.iit.nrc.ca/VoiceCode/demo-11-04-01.html">demo movie</A>). We achieve this goal through a <A HREF="command_index.html">series of voice commands</A> which are natural and easy to utter.


<H2><A NAME="using">Using VoiceCode</A></H2>

<H3><A NAME="simulation">Starting the Editor Simulator</A></H3>

To start the <EM>Editor Simulator</EM>, simply type the following at
the command prompt:

<P>

<UL>
   <LI>Make sure NatSpeak is started
   <LI>Go to a DOS window and type:
   <UL>
      <LI>cd %VCODE_HOME%\Mediator
      <LI>python gui_sim.py -s
   </UL>
</UL>

<P>

Then wait. The editor may take up to a minute to start. It will look
something like this:

<P>

<IMG SRC="???">???Put image of editor here???

<P>

The GUI for the <EM>Editor Simulator</EM> has 5 parts:

<UL>
<LI>the menu
<LI>the <EM>Microphone</EM> button
<LI>the <EM>Source buffer</EM> area
<LI>the <EM>Log</EM> area
<LI>the <A HREF="#shellCommands">Command prompt</A> area
</UL>

The <EM>menu</EM> is self-explanatory. 

<P>

The <EM>Microphone</EM> button appears just below the menu. It is used
to toggle the microphone on and off.

<P>

The <EM>Source buffer</EM> is a text area just beneath the
<EM>Microphone</EM> button. The code you are editing is displayed in
this area.

<P>

<A NAME="log"></A>
The <EM>Log</EM> is an other text area just beneath the <EM>Source
buffer</EM>. This is where VoiceCode messages get printed. It's mostly
meant as a debugging aid.

<P>

<A NAME="commandPrompt"></A>
The <EM>Command prompt</EM> is a text area at the bottom of the
window, where you can type Python statements that affect the state of
VoiceCode and the editor. It's also meant only as a debugging
tool. 

<P>

To start dictating, simply click on the <EM>Microphone</EM>
button. If you can't see the <EM>microphone</EM> button, or if
clicking on it doesn't work, read <A HREF="#micButton">this
section</A>.

<P>

Remember that with VoiceCode, you don't have to dictate code the way
it's written. In fact, that's the whole point of the system. Instead,
you dictate code using <A HREF="command_index.html">voice commands that are natural and easy to utter</A>. Note also that with VoiceCode, you can pretty much <A HREF="#pauses">pause anywhere you want</A> (or not).


<H3><A NAME="CSCs">Context Sensitive Commands (CSCs)</A></H3>

VoiceCode supports natural dictation of code through the use of
<EM>Context Sensitive Command (CSC)</EM> and <A HREF="#LSAs">Language
Sensitive Aliases</A>. A CSC is an utterance which may fire particular
actions in particular contexts. A CSC has the following attributes:

<DL>

<DT><EM>Spoken forms:</EM>

<DD>This is a list of all the different ways in which the CSC might be
pronouced.

<P>

<DT><EM>Contextual meanings:</EM>

<DD>This is a list of the different meanings that the CSC can take in
different contexts. Each contextual meaning is a pair consisting of a
<EM>context</EM> and an <EM>action</EM> to be taken if that context
applies.

</DL>

For example, suppose you want to create a CSC to dictate hash table access in Perl and Python, so that saying:

<P>

<EM>"x at key y"</EM> or<BR>
<EM>"x with key y"</EM>


<P>

types:

<P>

<PRE>x{y}</PRE> in Perl<BR>
<PRE>x[y]</PRE> in Python

<P>

All you have to do is to define a CSC with <EM>spoken form</EM> "at
key" (and possibly other forms like "with key") and two <EM>contextual
meanings</EM>. The first meaning would consist of a context object
that applies iif the current buffer is in Perl, and its action would
be to type "{}" and put the cursor in the middle. Similarly, the
second meaning would have a context object that applies iif the
current buffer is in Python, and its action would be to type "[]" and
put the cursor in the middle.

<P>

CSCs can also be used for implementing more complex behavior. For
example, suppose you want to be able to change the following C for
loop:

<P>

<PRE>
for (x = 0; x <= max; x++)
</PRE>

<P>

to:

<P>

<PRE>
for (x = 0; x >= max; x--)
</PRE>


by positioning the cursor on that line and saying:

<P>

<EM>"decreasing"</EM> or
<EM>"make that decreasing"</EM> or
<EM>"make it decreasing"</EM>

<P>

All you have to do is to implement a CSC with <EM>["decreasing", "make
that decreasing", "make it decreasing"]</EM> as its spoken form. The
command would have a contextual meaning with a context that applies
iif the cursor is on the first line of a for loop in a C file. The
action would be to change appropriate parts of the loop so that it is
decreasing instead of increasing.


<P>

VoiceCode comes bundled with a <A HREF="command_index.html">series of CSCs</A> for doing common tasks
in various languages. If you do not like the way a particular CSC is
implemented (for example, if you don't like the way it is said) or if
you want to add your own CSC, you can do that by <A
HREF="#config">modifying the VoiceCode configuration file</A>.

<P>

Note that for commands that only type text and position the cursor at
the end of that text, it is usually more convenient to define them as
<A HREF="#LSAs">Language Specific Aliases (LSAs)</A> instead of
CSCs.


<H3><A NAME="LSAs">Language Specific Aliases (LSAs)</A></H3>

<A HREF="#CSCs">Context Sensitive Commands</A> are meant to provide the user with enough flexibility to define very sophisticated commands and are consequently relatively complex. In most cases however, you can define a command using a simpler concept called Language Specific Alias (LSA). You can define a command as an LSA if:

<UL>
<LI>the command only inserts text at the current cursor location and puts the cursor at the end of that text
<LI>the inserted text only depends on the programming language of the current buffer
</UL>

Besides being simpler to define than CSCs, LSAs also have the
advantage that they can be used for <A HREF="#NavigateByPseudoSymbol">NavigationByPseudoCode</A>.

<P>

Like for CSCs, VoiceCode comes bundled with a <A HREF="command_index.html">series of LSAs</A> for doing
common tasks in various languages. If you do not like the way a
particular CSC is implemented (for example, if you don't like the way
it is said) or if you want to add your own LSA, you can do that by <A
HREF="#config">modifying the VoiceCode configuration file</A>.


<H3><A NAME="symbols">Dictating symbols</A></H3>

VoiceCode also allows you to dictate symbols by saying their "natural"
spoken form (we call this the pseudo-symbol form). For example, to
dictate a symbol:

<P>

<PRE>
a_pref_table
</PRE>

you might say the pseudo-symbol:

<P>

<EM>a preference table</EM>

<P>

and VoiceCode would type the desired native symbol.

<P>

The way that VoiceCode handles pseudo-symbols depends on whether the
corresponding native symbol is known or not.

<P>

If you have previously opened or <A HREF="#compiling">compiled</A> a
source file where the native symbol <EM>a_pref_table</EM> was defined,
then VoiceCode will simply map the uttered pseudo-symbol to the
compiled native. If there are more than one compiled symbols that
match the uttered pseudo-code, VoiceCode will select the one that
seems most likely. In the current version, that just means the longest
matching native symbol, but in the future VoiceCode may choose the
most recently used one, or the one that occurs closest to the cursor,
or the one that's most frequently used in the compiled files, or a
combination of those criteria.

<P>

If on the other hand, <EM>"a preference table"</EM> corresponds to a
new symbol or a symbol that hasn't been compiled, then VoiceCode will
automatically create a new symbol by concatenating these words
together using some formatting convention like:

<P>

<PRE>
a_preference_table, aPreferenceTable or A_PREFERENCE_TABLE
</PRE>

In the current version, the default formatting rule is <EM>a_preference_table</EM>. However <A HREF="#symbolFormatting">you can modify that</A>.

<P>

Note also that if VoiceCode doesn't format the symbol properly, there
is no way to tell it otherwise. In the future, you will be able to
select an improperly formatted symbol and ask VoiceCode to correct
it. It will then show you a list of other possible forms in a <A
HREF="#symbolFormatting">user configurable order</A>, from which you
will be able to pick the form that you want (or spell it if it's not
in the list).

<P>

Finally, when formatting a pseudo-symbol into a new native symbol,
VoiceCode makes no attempt at abbreviating words in the
pseudo-symbol. In the future, we plan to exploit the <A
HREF="#abbreviations">user provided abbreviations</A> as well as simple 
heuristics to abbreviate long words for which there is no predefined
abbreviations.


<H2><A NAME="NavigateByPseudoSymbol">NavigateByPseudoCode</A></H2>

VoiceCode supports a type of command which we call
<EM>NavigateByPseudoCode</EM>. This allows you to select or move the
cursor to a portion of visible code. All you have to do is say phrase
like: <A HREF="command_index.html#NavigateByPseudoCode">"Select",
"Before", "After", "Go", etc..</A> followed by a pseudo code dictation
of the native code you want to select or move the cursor
to. Note that contrarily to most VoiceCode commands,
<EM>NavigateByPseudoCode</EM> commands must be invoked as a single
utterance.

For example, suppose the following code is visible:

<PRE>
for (horiz_pos = 0; horiz_pos <= ^; ++)
{

}
</PRE>

(where ^ is the cursor position). Suppose you compiled that file (and had 
<A HREF="#abbreviations">defined an abbreviation</A> for <EM>'horiz'</EM>
and <EM>'pos'</EM>). Then if you say:

<EM>"select horizontal position equals zero"</EM>

<P>

you should get:

<P>

<PRE>
for(^^horiz_pos = 0^^; horiz_pos <= ; ++)
{

}
</PRE>

where ^^ denotes the boundaries of the selection. If you say:

<P>

<EM>after horizontal position equals 0</EM>

<P>

then you would get:

<P>

<PRE>
for(horiz_pos = 0^; horiz_pos <= ; ++)
{

}
</PRE>

As thes examples show, <EM>NavigateByPseudoCode</EM> works even if the
pseudo-code you dictate contains pseudo-symbols (e.g. <EM>"horizontal
position"</EM> for <EM>horiz_pos</EM>) and <A HREF="#LSAs">LSAs</A>
(e.g. <EM>"equals"</EM> for <EM>' = '</EM>). 

<P>

Note however that in the case of pseudo-symbols, this works only if
each of the abbreviations contained in the pseudo-symbol are known by
VoiceCode (either because you defined the abbreviation explicitely or
you previously dictated a new symbol that contained that abbreviation).

<P>

Note also, that you do not have to utter any of the punctuation marks
contained in the native form. This includes, but is not limited to
blank spaces. So for example, to select code <EM>"x, y, z"</EM>, you
could say: <EM>"Select x y z"</EM> (i.e. omit the commas).

<P>

<EM>NavigateByPseudoCode</EM> may not always work if the code
to be selected spreads across more than one line. For example, if the following code is visible:

<PRE>
x =
0
</PRE>

and you say: <EM>"Select x equals zero"</EM>, the selection will not
work. To select code that spreads across several lines, you must use
the <EM>"Select X through Y"</EM> syntax. In the above example,
this would be: <EM>"Select x through 0"</EM>

<P>

Also, the selection does not work if the
pseudo-code contains some <A HREF="#CSCs">CSCs</A>. For example, if
you have code:

<PRE>
x[0] = 1
</PRE>

then saying <EM>"Select x at index 0"</EM> will not work. This is
because <EM>"at index"</EM> is not an LSA (it types <EM>[]</EM> but
doesn't put the cursor at the end of it). To select <EM>x[0]</EM>, you
can however use one of the following approaches:

<P>

<EM>
<UL>
<LI>"select x open bracket 0 close bracket"
<LI>"select x through close bracket"
<LI>"select x 0 close bracket"
</UL>
</EM>

<H3><A NAME="shellCommands">The command prompt field</A></H3>

In the <EM>command prompt</EM> field, you can type Python statements
that affect the state of VoiceCode and the editor. It's meant mostly
as a debugging and testing aid. You can type any Python statement
there, but unless you are very familiar with the inner structure of
VoiceCode, you will probably want to limit yourself to invoking the
 functions described below.

<P>

<PRE>
help()
   display (this) list of commands

open_file(STR fname)
   Opens file with path name *fname* in the editor
   simulator. It also compiles a list of symbols for that file.
</PRE>

<A NAME="compiling">
<PRE>
compile_symbols([STR] file_list)
   Compiles symbols for all source files in list *file_list*.

   Note that opening a file in the editor simulator automatically invokes
   that command.

clear_symbols()
   Removes all spoken forms of symbols added by VoiceCode to NatSpeak's 
   vocabulary. Spoken forms which consist of a single word are however left
   there.

clear_abbreviations()
   Removes all defined abbreviations from VoiceCode's symbol dictionary

say(STR utterance, bypass_NatLink=1, user_input=None)
   Interprets string *utterance* as though it had been said by a user.
    
   *utterance* can be either:
   
       - a string with the written form of what should be recognised by the
         SR system
         e.g.: say('index not equal to 0')
         
       - a list of words in their written\spoken form (or just
         written if it doesn't have a spoken form different from its
         written form).
         e.g.: say(['index', ' != \\not equal to', '0'])
   

    In general, it's better to specify *utterance* as a list of
    written\spoken words because it allows to simulate exactly what
    the SR does (e.g. what if the SR recognises an LSA as a sequence
    of words instead of its written\spoken form?)

    Argument *user_input* is a string that will be sent to the
    mediator console's standard input. Use in automated regression
    testing, if the *say* command requires user additional user input
    (e.g. confirmation of a symbol match).
     
    If argument *bypass_NatLink* is true, the interpretation will be done
    withouth going through NatLink's recognitionMimic function.

goto(INT pos)
   Moves cursor to position *pos*

goto_line(INT linenum)
   Moves cursor to the beginning of line number *linenum*

select(INT start, end)
   Selects from position *start* to position *end* in current buffer

show_buff()
   Prints the content of the current buffer
   
print_abbreviations(show_unresolved=1)
   Prints out a list of the abbreviations in symbols that were parsed
   so far. If *show_unresolved=1*, also lists unresolved abbreviations
   and the symbols they appear in (an unresolved abbreviation is an
   abbreviation that appeared in a symbol and is neither a speech
   vocabulary word nor a known abbreviation).

print_error(STR message):
   Prints an error to stderr

print_symbols()
   Prints the list of symbols in the known symbols dictionary

provoke()
   causes an error deliberately
</PRE>

<h2><A NAME="commandIndex">VoiceCode commands</A></h2>

For a list of commands supported by VoiceCode, see <A
HREF="command_index.html">this page</A>.

<H2><A NAME="config">Configuring VoiceCode</A></H2>


<H3><A NAME="configFile">The VoiceCode configuration file</A></H3>

To change the behaviour of VoiceCode, simply edit the VoiceCode
configuration file. This is a file written in Python, but you don't
need to know the details of the Python syntax nor of VoiceCode to
modify it.

<P>

The VoiceCode configuration file has the following path:

<P>

<PRE>
%VCODE_HOME%\Config\vc_config.py
</PRE>

<H3><A NAME="debugConfig">Debugging the configuration file</A></H3>

The file <EM>vc_config.py</EM> is evaluated at run time by VoiceCode. If there are syntax errors in that file, the error reporting will therefore not be as precise as usual. You will probably get a message like:

<PRE>
ERROR: in configuration file D:\VoiceCode\VCode\Config\vc_config.py.

Traceback (innermost last):
  File "mediator.py", line 89, in ?
    raise err
</PRE>

with no indication of the line in <EM>vc_config.py</EM> where the
error occurred. You can however get better error reporting by running
<EM>vc_config.py </EM>directly from python as follows:

<PRE>
python %VCODE_HOME%\Config\vc_config.py
</PRE>


<H3><A NAME="customeCSCs">Customising CSCs</A></H3>


To modify the implementation of a <A HREF="#CSCs">Context Sensitive
Command (CSC)</A>, you must locate the statements that define that CSC
in the <A HREF="#configFile">VoiceCode configuration file</A>. The
statements that define CSCs look something like this:


<PRE>
acmd = CSCmd(spoken_forms=['new list', 'list with elements'], 
             meanings=[[ContPy(), gen_brackets_pair], 
                       [ContPerl(), gen_parens_pair]])
add_csc(acmd)
</PRE>


Basically, these two statements create a new instance of <A
HREF="CSCmd.CSCmd.html">CSCmd</A> which defines a CSC, and then
register that instance with VoiceCode through the <EM>add_csc</EM>
function.

<P>

The <EM>CSCmd</EM> constructor has the following named arguments:

<DL>
<DT><STRONG>[STR] spoken_forms</STRONG> 
<DD>the <EM>spoken_form</EM> argument
is a list defining the various ways that the command can be invoked by
voice. If you prefer to use a different voice command, just add your
own to that list. 

<P>

<DT><STRONG>[[Context, FCT]] meanings</STRONG>  
<DD>the <EM>meanings</EM> argument is a list of contextual meanings for the command. Each contextual meaning is a pair consisting of a context object (which is used to determine if a particular context applies) and an action function to be fired if the context applies.

</DL>

In the above example, the command has two spoken forms: <EM>'new
list'</EM> and <EM>'list with elements'</EM>. The command can be used
in one of two contexts: <EM>ContPy</EM> and <EM>ContPy</EM>, which
respectively apply iif the current source buffer is in <EM>Python</EM>
or <EM>Perl</EM>. In the Python context, the action is
<EM>gen_brackets_pair</EM> which just types <EM>[^]</EM> (where ^
denotes the cursor position). But in the Perl context the action is
<EM>gen_parens_pair</EM> which inserts <EM>(^)</EM> instead.

<P>

The various <A HREF="Context.Context.html">Context</A> object and the
various <EM>action</EM> functions that can be used to build <A
HREF="CSCmd.CSCmd.html">CSCmd</A> objects are defined in the following
files:

<P>

<UL>
<LI><STRONG>$VCODE_HOME/Mediator/cont_gen.py: </STRONG> defines context objects which are not specific to a particular programming language
<LI><STRONG>$VCODE_HOME/Mediator/actions_gen.py:</STRONG> defines action functions which are relevant across different programming languages.
<LI><STRONG>$VCODE_HOME/Mediator/actions_py.py:</STRONG> defines action functions relevant only for the <EM>Python</EM> language.
<LI><STRONG>$VCODE_HOME/Mediator/actions_C_Cpp.py:</STRONG> defines action functions relevant only for the <EM>C</EM> and <EM>C++</EM> languages.
<LI><STRONG>$VCODE_HOME/Mediator/actions_perl.py:</STRONG> defines action functions relevant only for the <EM>Perl</EM> language.
</UL>

Of course, you are not limited to those contexts and actions. You can add your own and then use them to build <A HREF="CSCmd.CSCmd.html">CSCmd</A> objects in <EM>vc_config.py</EM>.


<H3><A NAME="customLSAs">Customising LSAs</A></H3>

To modify the implementation of a <A HREF="#LSAs">Language Sensitive Alias (LSA)</A>, you must locate the statements that define that LSA
in the <A HREF="#configFile">VoiceCode configuration file</A>. The
statements that define LSAs look something like this:

<PRE>
add_lsa(['empty list'], {'python': '[]', 'perl': '()'})
</PRE>

The first argument of <EM>add_lsa</EM> is the list of spoken forms for
the LSA. The LSA will be invoked when any of those spoken forms is
uttered in a file of an appropriate language. In the above example,
there is only one spoken form: <EM>'empty list'</EM>, but you are not limited to that.

<P>

The second argument is a dictionary specifying the written form of the
LSA for each of the programming languages where it applies. If the
current language is not listed in that dictionnary, the LSA will not
invoked and the user's utterance will be treated by VoiceCode as a <A
HREF="#symbols">pseudo-symbol</A>. In the above example, the LSA
applies in either Python or Perl buffers. In the Python context, it
types empty brackets while in the Perl context it types empty parens.


<H3><A NAME="abbreviations">Adding/modifying abbreviations</A></H3>

When compiling symbols from source files (<A
HREF="#compiling">compile_symbols</A> command), VoiceCode
automatically generates a pseudo-symbol for every native symbol that
it parses. A pseudo-symbol is essentially an easy to utter alias for the native
symbol. The pseudo-symbol is a phrase obtained by splitting the symbol
into a sequence of parts that are either in-vocabulary words or known
abbreviation. For parts that correspond to a known abbreviation,
VoiceCode will substitute the abbreviation's expansion. Abbreviations
and their expansions are defined in the <A
HREF="#configFile">VoiceCode configuration file</A>.

<P>

For example, suppose that the following statements are included in the
configuration file:

<PRE>
add_abbreviation('horiz', ['horizontal', 'horizontally'])
add_abbreviation('pos', ['position', 'positive'])
</PRE>

Then VoiceCode would create the following spoken forms for native
symbol <EM> horiz_pos</EM>:

<EM>
<UL>
<LI>horizontal position
<LI>horizontal positive
<LI>horizontally position
<LI>horizontally positive
</UL>
</EM>

Obviously, <EM>horizontal position</EM> is probably the only one that
makes sense for that symbol, but VoiceCode can't tell and will
generate all of them.

<P>

Note that you don't necessarily have to define all the abbreviations
used in a native symbol in order to be able to utter it as a
pseudo-symbol. However, defining abbreviations will help in two ways.

<P>

Firstly, it will improve the SR's accuracy for recognising the
pseudo-symbol. Pseudo-symbols are often gramatically incorrect and/or
atypical of what you say in plain English (e.g. <EM>"source buffer
editor simulator"</EM> for native symbol
<EM>SourceBuffEdSim</EM>). Consequently, the SR system tends to have a
lower recognition accuracy for pseudo-symbols. But if VoiceCode knows
all the abbreviations used in a native symbol, it will add a
written-form\spoken-form entry for that symbol in the SR
system's vocabulary, which greatly increases the likelyhood that the
SR will recognise it.

<P>

Secondly, defining abbreviatiosn allows you to use the pseudo-symbol in <A
HREF="#NavigateByPseudoSymbol">NavigateByPseudoCode</A> commands. For example, suppose you
want to say: <EM>"Select source buffer editor simulator"</EM> to
select native symbol <EM>SourceBuffEdSim</EM>. The only way that this
will work is if the SR has a vocabulary entry
<EM>'SourceBuffEdSim\source buffer editor simulator'</EM> in its
vocabulary. But as we mentioned above, VoiceCode will only generate
such an entry if it knows the expansion of all the abbreviations in
<EM>SourceBuffEdSim</EM>.

<P>

Note also that you don't need to define plural forms of
abbreviations because VoiceCode automatically pluralises abbreviations
when needed. For example suppose you define:

<P>

<PRE>
add_abbreviation('cmd', ['command'])
</PRE>

then for symbol <EM>all_cmds</EM>, VoiceCode would still be able to
generate spoken form <EM>'all commands'</EM>.

<P>

At the moment, VoiceCode doesn't use known abbreviations to abbreviate
words when <A HREF="#symbols">creating new symbols</A>. For example, if
the user dictates a new symbol as <EM>"a preference table"</EM>,
VoiceCode will generate a new symbol like <EM>a_preference_table</EM>,
even if the user has defined abbreviation <EM>pref</EM> for
<EM>preference</EM>. In this situation, a better choice for the new
symbol would be <EM>a_pref_table</EM>. We plan to support this in the
future.

<H3><A NAME="symbolFormatting">Changing symbol formatting conventions</A></H3>

When VoiceCode <A HREF="#symbols">creates a new native symbol</A>
based on an uttered pseudo-symbol, it creates the symbol using the
format <EM>a_new_symbol</EM>. When correcting the symbol (which is not
currently supported), it also displays alternative formats in a
predefined order.

<P>

While it is possible to add/remove symbol formatting conventions and modify the order in which alternative formats are displayed, it is not currently possible to do so through <EM>vc_config</EM> (although it will be in the future). If you want to customise symbol formatting, you will have to read the part of file <EM>Mediator/SymDict.py</EM> which starts with the comment:

<P>

<PRE>
#############################################################################
# Symbol formatting functions
#
# List of formatting functions for generating new native symbols from
# pseudo_symbols.
#
# Each formatting function must return a valid SymbolMatch object.
#
#############################################################################
</PRE>

<H3><A NAME="VCODE_NOSPEECH">Running the Editor Simulator  without NatSpeak</A></H3>

<EM>21/04/01 I think this is broken, but I'm not sure anybody cares
cause we all have NatSpeak anyways. I keep it here in case someone
does eventually care - Alain Désilets</EM>

<P>

You can run VoiceCode <EM>Editor Simulator</EM>, even if you don't have
NatSpeak installed.

<P>

Simply set environment variable <EM>VCODE_NOSPEECH</EM> before
invoking <EM>mediator.py</EM> (the actual value you set it to is
irrelevant).

<P>

You can then simulate utterances using the <A
HREF="#shellCommands">say</A> shell command with <EM>bypass_NatLink=1</EM>.


<H2><A NAME="trouble">Trouble shooting</A></H2>

Below is a list of common problems and fixes. If you experience a bug that's not in this list, <A HREF="mailto:alain.desilets@nrc.ca">please report them</A>.

<h3><A NAME="micButton">No mic button in Editor Simulator</A></h3>

Some people have reported that they don't see a microphone button at
the top of the <EM>Editor Simulator</EM>. We don't know the reasons
for that, but the button is in fact there eventhough you can't see
it. To toggle the mic, just click to the right of the
<EM>Microphone</EM> label. A message should appear in the <A
HREF="#log">log</A> area echoing the new state of the microphone.

<P>

If clicking right of the <EM>Microphone</EM> label still doesn't work,
try typing one of the commands below in the <A
HREF="#commandPrompt">command prompt</A> field:

<P>

<PRE>
setmic('on')
setmic('off')
</PRE>


<h3><A NAME="accuracy">Accuracy is poor</A></h3>

One the missing pieces in this Alpha-minus-1 version is a correction
mechanism. In a few months from now, we hope to have something running
that will support correction of the last utterance. But in the mean
time, there is no easy way to train NatSpeak to recognise "Codese" as
opposed to plain English.

<P>

But there are two things you can do to help with accuracy. 

<P>

First, make sure you use a copy of your regular NatSpeak user as your
<A HREF="install.html#VoiceCode_user">VoiceCode user</A>. Although
"Codese" is quite different from plain English, one of the goals of
VoiceCode is to make it closer to natural English. So a user trained
to natural English may still be better at understanding "VoiceCodese" than
an untrainted user.

<P>

Second, you can feed some "VoiceCodese" files to NatSpeak for
training. Basically, take a few source files that are representative
of the code you write, then translate them to the sequence of <A
HREF="command_index.html">VoiceCode commands</A> that you would use to
type that code. Then make a thouasand copies of those files and feed
them to NatSpeak's vocabulary builder. 

<H3><A NAME="notResponding">VoiceCode doesn't hear me</A></H3>

If VoiceCode doesn't respond to your voice commands, first make sure
that the microphone is togggled on. If the mic is on and it still
doesn't respond, try the following:

<P>

<UL>
<LI>close NatSpeak if it's running
<LI>make sure there are no <EM>natspeak</EM> processes running (<EM>Ctrl+Alt+Del->Task Manager->Processes</EM> then click on <EM>natspeak</EM> in the list and click on <EM>End Process</EM>)
</UL>

If that still doesn't work, try the 3 finger solution (i.e. rebooting ;-).

<h3><A NAME="noTranslation">VoiceCode doesn't translate pseudo-code to native code</A></h3>

This may happen if you are using VoiceCode while NatSpeak (i.e. Dragon's desktop application) is running. To fix this, try the same steps as for <A HREF="#notResponding">this problem</A>.

<H3><A NAME="undefinedUser">ERROR: <EM>SR user 'VoiceCode' not defined.</EM></A></H3>

If the mediator exits with this error message, it means that you
forgot to define the user <EM>VoiceCode</EM> in your Speech
Recognition system. This is the special user that VoiceCode employs to
connect to your SR system in order to not bias your regular user
towards code dictation.

<P>

To solve this problem, <A HREF="install.html#VoiceCode_user">create a VoiceCode user</A>, then exit
your SR system (making sure to save the new user), then restart
VoiceCode.

<h3><A NAME="SRERR_VALUEOUTOFRANGE">When I start VoiceCode, I get <EM>SRERR_VALUEOUTOFRANGE error</EM></A></h3>

We have experienced this error a number of times but have not been
able to identify the exact circumstances under which it happens. If
you figure out a recipe for consistently reproducing this problem,
please <A HREF="mailto:alain.desilets@nrc.ca">send us your
findings</A>.

<P>

We have found that you can sometimes fix the problem by starting
NatSpeak and then closing it (using VoiceCode and NatSpeak
concurrently sometimes causes problems). <STRONG>Don't</STRONG> kill
the <EM>natspeak</EM> process using the task manager.


<hr>
<center>
<TABLE  border="1" >
    <tr><td><font size=2>
    [<A HREF="http://ii2.ai.iit.nrc.ca/VoiceCode/">VoiceCode Home</A> |
    <A HREF="http://ii2.ai.iit.nrc.ca/VoiceCode/contact.html">Contact</A> |
    <A HREF="http://ii2.ai.iit.nrc.ca/VoiceCode/pbvResources.html">PBV Resources</A> |
    <A HREF="http://www.iit.nrc.ca/english.html">IIT</A> |
    <A HREF="http://www.nrc.ca/corporate/english/">NRC</A> |
    <A HREF="mailto:alain.desilets@nrc.ca">Feedback</A> ]
    </FONT></td>
   </tr>
</table>
</center>


</BODY>
</HTML>
