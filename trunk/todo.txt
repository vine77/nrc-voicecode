Todo list for VoiceCode
=======================

Selec XYZ
---------

- Suppose you want to select '!='. At the moment, you can't say "Select not equal", because there isn't a word with form '!=\not equal'. We could add such a word, but that might be a problem because 'not equal' may be written differently in different languages.

  We could add a new kind of statement to the config file

  language_specific_word(STR spoken_as, [(STR language, STR written_as)]

  where STR spoken_as is the spoken form of the word and the 2nd argument is 
  a list showing how the word is written in different languages. 

  the language specific words for a given langauge would only be
  loaded when we are editing a file of the appropriate language. That
  is, as soon as we intercept the beginning of an utterance, we first
  check to see the language of the current buffer. If it's the same as
  the language for which the language specific words were loaded, we
  do nothing. Otherwise, we delete all language specific words for the
  previous language and load those for the current language.

  
config.py
---------

-- Alain

CSCmd should have a __setattr__ method that intercepts sets to the
*meanning* attribute. It would check to make sure that each entry in
meanings is OK, i.e. it's a pair with 1st element being a context
instance and the second being a function pointer.

This would address the common mistake where a user adds the following
configuration statement.

add_csc(spoken_forms=['for loop'], meanings=[[ContC, c_simple_for]])

i.e. the user forgets to add () after ContC, which means he is making
the context be the ContC class itself (as opposed to a ContC INSTANCE)


Grammar for spoken forms
------------------------

Instead of having to encode all the spoken forms of a command from
scratch, it would be better to allow grammar rules instead.

For example instead of:

spoken_forms=['after ;', 'after semi', 'after semicolon', 'goto semi', 'goto semicolon', 'goto ;', 'go semi', 'go semicolon', 'go ;', 'go after semi', 'go after semicolon', 'go after ;']

we could have:

spoken_forms=['after* (semi|semicolon|;)', 'go after* (semi|semicolon|;)']


Symbol translation
------------------

- When a word in a symbol doesn't correspond to an in-vocab word or a
  known abbreviation, we should see if it's a concatenation or such
  words and/or abbreviations.
