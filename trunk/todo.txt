Todo list for VoiceCode
=======================

To do before 1st release
========================

Documentation
-------------

Installation, user, developper


Emacs mediator link
-------------------

Must be implemented


Mediator based CachePad
-----------------------

Jonathan is working on it, but not absolutely necessary for 1st release.


Error correction
----------------

Can't do without it. David Fox is working on it.


User/Topic management
---------------------

Mediator should set NatSpeak so that it uses a special topic (or user
if the version of NatSpeak doesn't have topics), to avoid polluting
the user's regular user/topic with automatically generated entries.

Symbol translation
------------------

-- Alain

  VG3 style symbol translation

  When a sequence of words in an utterance doesn't correspond to a CSC
  or LSA (e.g. '!=\not equal to'), or a compiled symbols with known
  spoken form (e.g. 'horiz_pos\horizontal position'), should try to
  match the sequence to one of the compiled symbols without a known
  spoken form (i.e. symbols that contain undefined abbreviations), a la VG3.

  If a match is found, the symbol would be added to the list of
  symbols with known spoken form (and added to NatSpeak's
  vocabulary). It should also be possible to identify which parts of
  the written form correspond to which words of the spoken form and
  automatically add new known abbreviations.

  If no match is found, then the system would automatically abbreviate
  the symbol for the user and add corresponding abbrevs and voc
  entries.

  Before doing either translations, the system should display a dialog
  asking the user if he/she wants to create such symbols and
  abbrevs. If the suer says no, just type the text as is.

  Note that this dialog would be displayed only the first time the
  user dictates a pseudo symbol. The next time, there would not be
  such a dialog because NatSpeak would have a corresponding entry in
  its vocab.

  I think this feature is absolutely necessary, otherwise, it will be
  a real pain for users to define abbrevs for all the symbols they
  compile.

    NOTE: there could be more than one MediatorObject modifying the
   abbreviations file at the same time... how to keep them in sync?

   Maybe the Mediator server should handle changes to the abbrevs file
   and use a locking mechanism so that only one thread at a time could
   update it. What happens if the thread in question dies? Need to
   have a time out so that the server can unlock the file after a few
   seconds (assume that the update doesn't take long).


Text mode
---------

-- Alain

Need to be able to turn CSC interpretation off so that you can dictate
comments and quoted strings. Maybe that mode could switch on/off
automatically depending on the current mode.


Basic LSAs and CSCs for a few languages
---------------------------------------

Just enought to entice people into writing more.

Python, C and what else?


getWordInfo
-----------

-- Alain: this is not absolutely necessary, but it's so easy to do:
   might as well do it.

In sr_interface.getWordInfo, if no flag is specified, should use
flag = 1 (i.e. look in backup dictionary).


Select Pseudo-code
------------------

-- Alain

  Should extend the Select grammar so that it allows commands like:

  go (before|after)* (previous|next)* X this would position the cursor
     before or after the previous or next occurence of X. If
     (before|after) is not specied, it would default to say after. If
     (previous|next) is not specified, it would go to the closest one.

  select from (before|after)* (previous|next)* X up to (before|after)*
     (previous|next)* Y selects code from X up to Y. Both of X, Y can
     be optionally qualified as above by (previous|next) and
     (before|after).


Interpreter
-----------

Should it take into account the word property (space adding?) or is
that done automatically by VDct?

Symbol compilation
------------------

-- Alain

Should add symbols with word info such that a blank space is inserted after it.


add_lsa
-------

-- Alain

Right now, there is no way to edit the word info with add_lsa. In
particular, this means you can't say whether there should be spaces
before or after an LSA.

Should modify add_lsa so it allows to specify the word info (full word
info or just spacing?)


-- Alain

In vc_config.py, there are many commands which are implemented as CSCs
but would be better implemented as LSAs.

-- Alain

At the moment, if the same words mean different things in different
langauges, you need to define them as two separate add_lsa
commands. It would be better if a single command allowed you to define
different written forms for different languages.


Can wait after 1st release
==========================

addWord
-------

Joel Gould claims that Select XYZ works as long as the written form of
XYZ doesn't have leading/trailing spaces. So addWord doesn't have to
add redundant vocabulary entry for words whose written form only
contains internal spaces. TEST THE CLAIM BEFORE TRYING TO IMPLEMENT
THIS.


-- Alain

   Should be able to qualify a previous Select command. For example, could say:

   - say "Select X"
   - pause
   - if the system didn't select the right one, say "previous one" or 
     "next one" to select the previous or next instance of X

   Other examples of qualifications would be:

   - "select from X" [pause] "up to Y" 
	can be useful if X and/or Y are
        long to say and/or you realise in mid command that you don't
        really know where you want the selection to end

   - "select from X up to Y" [pause] "extend left"
        useful if didnt select from right instance of X but ended at the right
        instance of Y

   This could be implemented as follows:

   Every time a SelectXYZ command is recognised, the system would log
   an entry in the command history describing the arguments of that
   command.

   There would be a context class ContSelectXYZ that would apply
   whenever the last CSC in the command history was a SelectXYZ command.

   There would be CSCs with ContSelectXYZ as their context and the
   appropriate action methods (e.g. change the begining/end of the
   selection).

   This is a specialised example of command qualification which is described 
   below


Command qualification
---------------------

It woudl be nice if a command could qualify a previous command. For example, if you say: 

"page down" [pause] "keep doing that" OR
"page down" [pause] "again 2 times"

the "keep doing that" part means keep doing the previous command and "again 2 times" means do the previous command 2 times. An other example is:

"select XYZ" [pause] "previous one"

here "previous one" means select the previous occurence of XYZ.

Note that this kind of qualification should only apply if specific
types of commands were dictated last. For example, "previous one" can
only qualify CSC that are of type *linear_selection* (i.e. selecting
an item from a linear list, where the concept of a previous and next
item makes sense). This is because if I say:

"table at index previous one"

I probably mean something like:

table[prev_one]

Similarly, "keep doing that" and "again 2 times" should only apply for commands of type "repeatable".

One way to implement that is to create Context classes that applie
only if the last CSC in the command history is of a particular type. This also assumes that the Context object is able to find out certain information about what the CSC eventually did. For example, in the example:

"select XYZ [pause] previous one"

the CSC "previous one" needs to know what XYZ was and which occurence
of it it choose. This means that the logging mechanism has to be sophisticated enough to remember this sort of thing.


config.py
---------

-- Alain

CSCmd should have a __setattr__ method that intercepts sets to the
*meanning* attribute. It would check to make sure that each entry in
meanings is OK, i.e. it's a pair with 1st element being a context
instance and the second being a function pointer.

This would address the common mistake where a user adds the following
configuration statement.

add_csc(spoken_forms=['for loop'], meanings=[[ContC, c_simple_for]])

i.e. the user forgets to add () after ContC, which means he is making
the context be the ContC class itself (as opposed to a ContC INSTANCE)


add_lsa
-------

-- Alain

At the moment, whenever you switch language, you need to unload all
the aliases for that language, and then load those for the new
languages. It might be more efficient to only unload/load those
aliases which are not in both languages.

For example, 'not equal to' means the same thing in C and in Python '
!= '. So no need to unload/reload it. On the other hand, 'with key'
exists in both Python and Perl, but doesn't mean the same thing ('[]'
versus '{}'). So in this case, would need to unload/reload.

Need to check first if this optimisation is really needed.


CSCs
----

--- Alain

It would be nice if you could associate an action with different contexts (e.g. for word 'equals', associate action type_equal_sign to either C, python, etc.. contexts).

This could be done by making the contextual meaning to have a list of contexts associated with an action:

acmd = CSCmd(spoken_forms=['equals', 'assigned value', 'is assigned value'], meanings=[[ContPy(), ContC, type_equal_sign])
add_csc(acmd)


An other approach is to create an OR context that could be instantiated by feeding the various ORed contexts to it. This would be syntactically nasty:

acmd = CSCmd(spoken_forms=['equals', 'assigned value', 'is assigned value'], meanings=[[ContOR(terms=[ContPy(), ContC()]), type_equal_sign])
add_csc(acmd)


Grammar for spoken forms
------------------------

Instead of having to encode all the spoken forms of a command from
scratch, it would be better to allow grammar rules instead.

For example instead of:

spoken_forms=['after ;', 'after semi', 'after semicolon', 'goto semi', 'goto semicolon', 'goto ;', 'go semi', 'go semicolon', 'go ;', 'go after semi', 'go after semicolon', 'go after ;']

we could have:

spoken_forms=['after* (semi|semicolon|;)', 'go after* (semi|semicolon|;)']


Symbol translation
------------------

-- Alain

  When a word in a symbol doesn't correspond to an in-vocab word or a
  known abbreviation, we should see if it's a concatenation or such
  words and/or abbreviations.

  
What can I say
--------------

-- Alain

  The mediator console should allow the user to browse through the
  list of CSCs and LSAs by language and topic.

  The user could even ask to see what LSAs and CSCs are applicable in
  the current context (actually, CSCs should be sufficient since a CSC
  is generated automatically for each LSA).

  This feature would use the _doc_ attributes of the Context objects
  and the action functions.

  Example of subject hierarchy for what can I say

  C
    - loops
       for 
       while
       repeat
       etc...
    - conditionals
       if
       then
       else
       switch
       etc...
    - functions
       declaring
       calling
    - precompiler directives
       #include
       etc...
    etc...
   Python
    - loops
        for
    etc...
       
    
