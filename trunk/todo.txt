Todo list for VoiceCode
=======================


addWord
-------

Joel Gould claims that Select XYZ works as long as the written form of
XYZ doesn't have leading/trailing spaces. So addWord doesn't have to
add redundant vocabulary entry for words whose written form only
contains internal spaces. TEST THE CLAIM BEFORE TRYING TO IMPLEMENT
THIS.

getWordInfo
-----------

In sr_interface.getWordInfo, if no flag is specified, should use
flag = 1 (i.e. look in backup dictionary).

Select Pseudo-code
------------------

-- Alain

  Suppose you want to select '!='. At the moment, you can't say
  "Select not equal", because there isn't a word with form '!=\not
  equal'. We could add such a word, but that might be a problem
  because 'not equal' may be written differently in different
  languages.

  We could add a new kind of statement to the config file

  language_specific_alias(STR spoken_as, [(STR language, STR written_as)]

  where STR spoken_as is the spoken form of the word and the 2nd argument is 
  a list showing how the word is written in different languages. 

  the language specific words for a given langauge would only be
  loaded when we are editing a file of the appropriate language. That
  is, as soon as we intercept the beginning of an utterance, we first
  check to see the language of the current buffer. If it's the same as
  the language for which the language specific words were loaded, we
  do nothing. Otherwise, we delete all language specific words for the
  previous language and load those for the current language.

  This has been implemented and works well for selection, but there is
  a problem for dictation of the aliases. NatSpeak will often insist
  on sending those utterances to the Mediator as dictated text instead
  of their written form. So, add_lsa should enable
  translation of this also at the level of the mediator in case
  NatSpeak fails to do so. 

  An easy way for Mediator to support translation of aliases both at
  the NatSpeak and Mediator level would be for
  add_lsa to automatically add a CSC with the
  appropriate languages context and the appropriate action. This would
  require some changes to the languages contexts (e.g. ContC,
  ContPy). At the moment, these contexts can't be created on the fly
  based on the name of a language, unless you do an ugly hack with
  eval like:

       context = eval("Cont" + language + "()") ). 

  It would be better to define a base class ContLanguage with
  attribute language_name. Then, we could create a context for
  languages X by writing:

       context = ContLanguages(language_name=X)

  For syntactic simplicity, we could still define ContC and ContPy as
  actual classes (and their constructor would set language_name to the
  appropriate value) so that we could write a CSC as:

    acmd = CSCmd(spoken_forms=['equals', 'assigned value', 
                               'is assigned value'], 
			       meanings=[[ContPy(), type], 
			                 [ContC(), c_assignment]]) 

  instead of:

    acmd = CSCmd(spoken_forms=['equals', 'assigned value', 
                               'is assigned value'], 
			       meanings=[[ContLanguage(language_name='python'), type], 
			                 [ContLanguage(language_name='C'), c_assignment]]) 


-- Alain

  Should extend the Select grammar so that it allows commands like:

  go (before|after)* (previous|next)* X this would position the cursor
     before or after the previous or next occurence of X. If
     (before|after) is not specied, it would default to say after. If
     (previous|next) is not specified, it would go to the closest one.

  select from (before|after)* (previous|next)* X up to (before|after)*
     (previous|next)* Y selects code from X up to Y. Both of X, Y can
     be optionally qualified as above by (previous|next) and
     (before|after).


-- Alain

   Should be able to qualify a previous Select command. For example, could say:

   - say "Select X"
   - pause
   - if the system didn't select the right one, say "previous one" or 
     "next one" to select the previous or next instance of X

   Other examples of qualifications would be:

   - "select from X" [pause] "up to Y" 
	can be useful if X and/or Y are
        long to say and/or you realise in mid command that you don't
        really know where you want the selection to end

   - "select from X up to Y" [pause] "extend left"
        useful if didnt select from right instance of X but ended at the right
        instance of Y

   This could be implemented as follows:

   Every time a SelectXYZ command is recognised, the system would log
   an entry in the command history describing the arguments of that
   command.

   There would be a context class ContSelectXYZ that would apply
   whenever the last CSC in the command history was a SelectXYZ command.

   There would be CSCs with ContSelectXYZ as their context and the
   appropriate action methods (e.g. change the begining/end of the
   selection).

   This is a specialised example of command qualification which is described 
   below


Command qualification
---------------------

It woudl be nice if a command could qualify a previous command. For example, if you say: 

"page down" [pause] "keep doing that" OR
"page down" [pause] "again 2 times"

the "keep doing that" part means keep doing the previous command and "again 2 times" means do the previous command 2 times. An other example is:

"select XYZ" [pause] "previous one"

here "previous one" means select the previous occurence of XYZ.

Note that this kind of qualification should only apply if specific
types of commands were dictated last. For example, "previous one" can
only qualify CSC that are of type *linear_selection* (i.e. selecting
an item from a linear list, where the concept of a previous and next
item makes sense). This is because if I say:

"table at index previous one"

I probably mean something like:

table[prev_one]

Similarly, "keep doing that" and "again 2 times" should only apply for commands of type "repeatable".

One way to implement that is to create Context classes that applie
only if the last CSC in the command history is of a particular type. This also assumes that the Context object is able to find out certain information about what the CSC eventually did. For example, in the example:

"select XYZ [pause] previous one"

the CSC "previous one" needs to know what XYZ was and which occurence
of it it choose. This means that the logging mechanism has to be sophisticated enough to remember this sort of thing.


config.py
---------

-- Alain

CSCmd should have a __setattr__ method that intercepts sets to the
*meanning* attribute. It would check to make sure that each entry in
meanings is OK, i.e. it's a pair with 1st element being a context
instance and the second being a function pointer.

This would address the common mistake where a user adds the following
configuration statement.

add_csc(spoken_forms=['for loop'], meanings=[[ContC, c_simple_for]])

i.e. the user forgets to add () after ContC, which means he is making
the context be the ContC class itself (as opposed to a ContC INSTANCE)

add_lsa
-------

-- Alain

In vc_config.py, there are many commands which are implemented as CSCs but would be better implemented as LSAs.

-- Alain

At the moment, if the same words mean different things in different
langauges, you need to define them as two separate add_lsa
commands. It would be better if a single command allowed you to define
different written forms for different languages.

-- Alain

At the moment, whenever you switch language, you need to unload all
the aliases for that language, and then load those for the new
languages. It might be more efficient to only unload/load those
aliases which are not in both languages.

For example, 'not equal to' means the same thing in C and in Python '
!= '. So no need to unload/reload it. On the other hand, 'with key'
exists in both Python and Perl, but doesn't mean the same thing ('[]'
versus '{}'). So in this case, would need to unload/reload.

Need to check first if this optimisation is really needed.


CSCs
----

--- Alain

It would be nice if you could associate an action with different contexts (e.g. for word 'equals', associate action type_equal_sign to either C, python, etc.. contexts).

This could be done by making the contextual meaning to have a list of contexts associated with an action:

acmd = CSCmd(spoken_forms=['equals', 'assigned value', 'is assigned value'], meanings=[[ContPy(), ContC, type_equal_sign])
add_csc(acmd)


An other approach is to create an OR context that could be instantiated by feeding the various ORed contexts to it. This would be syntactically nasty:

acmd = CSCmd(spoken_forms=['equals', 'assigned value', 'is assigned value'], meanings=[[ContOR(terms=[ContPy(), ContC()]), type_equal_sign])
add_csc(acmd)


Grammar for spoken forms
------------------------

Instead of having to encode all the spoken forms of a command from
scratch, it would be better to allow grammar rules instead.

For example instead of:

spoken_forms=['after ;', 'after semi', 'after semicolon', 'goto semi', 'goto semicolon', 'goto ;', 'go semi', 'go semicolon', 'go ;', 'go after semi', 'go after semicolon', 'go after ;']

we could have:

spoken_forms=['after* (semi|semicolon|;)', 'go after* (semi|semicolon|;)']


Symbol translation
------------------

- When a word in a symbol doesn't correspond to an in-vocab word or a
  known abbreviation, we should see if it's a concatenation or such
  words and/or abbreviations.
