<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>

<head>

<META NAME="GENERATOR" CONTENT="pythondoc 0.7 (Tue Dec 19 01:20:14 2000)">

<link rel="stylesheet" href="pythondoc.css" type="text/css">

<title>Class SourceBuffEdSim</title>
</head>

<body>
<P><A HREF="index.html">Table of contents</A> <A HREF="indices.html">Index</A></P>


<H1 CLASS="ClassName">class SourceBuffEdSim</H1>
<P CLASS="DeclaredIn">Declared in module <A HREF="SourceBuffEdSim.html">SourceBuffEdSim</A></P>

<H2 CLASS="ClassHierarchy">Inheritance hierarchy:</H2><P CLASS="ClassHierarchy">SourceBuffEdSim.SourceBuffEdSim<BR>
&nbsp;&nbsp;SourceBuff.SourceBuff<BR>
</P>

<H2>Synopsis</H2>
<PRE CLASS="ClassDeclaration">
<SPAN CLASS="PyKeyword">class</SPAN> <SPAN CLASS="ClassName">SourceBuffEdSim</SPAN>(<A CLASS="DocLink" HREF="SourceBuff.SourceBuff.html">SourceBuff</A>):
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuffEdSim.SourceBuffEdSim.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">init_pos=0</SPAN>, <SPAN CLASS="Argument">init_visible=None</SPAN>, <SPAN CLASS="Argument">init_selection=None</SPAN>, <SPAN CLASS="Argument">initial_contents=''</SPAN>, <SPAN CLASS="Argument">**attrs</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuffEdSim.SourceBuffEdSim.cur_pos</SPAN>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#SourceBuffEdSim.SourceBuffEdSim.delete"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuffEdSim.SourceBuffEdSim.delete</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">range=None</SPAN>)<SPAN CLASS="OneLiner"> # Delete text in a source buffer range.</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuffEdSim.SourceBuffEdSim.get_selection</SPAN>(<SPAN CLASS="Argument">self</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuffEdSim.SourceBuffEdSim.get_text</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">start=None</SPAN>, <SPAN CLASS="Argument">end=None</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuffEdSim.SourceBuffEdSim.get_visible</SPAN>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#SourceBuffEdSim.SourceBuffEdSim.goto"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuffEdSim.SourceBuffEdSim.goto</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">pos</SPAN>)
    <A CLASS="DocLink" HREF="#SourceBuffEdSim.SourceBuffEdSim.goto_line"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuffEdSim.SourceBuffEdSim.goto_line</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">linenum</SPAN>, <SPAN CLASS="Argument">where=-1</SPAN>)<SPAN CLASS="OneLiner"> # Go to a particular line in a buffer.</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuffEdSim.SourceBuffEdSim.indent"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuffEdSim.SourceBuffEdSim.indent</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">range=None</SPAN>)<SPAN CLASS="OneLiner"> # Indent code in a source buffer region.</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuffEdSim.SourceBuffEdSim.insert"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuffEdSim.SourceBuffEdSim.insert</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">text</SPAN>, <SPAN CLASS="Argument">range=None</SPAN>)
    <A CLASS="DocLink" HREF="#SourceBuffEdSim.SourceBuffEdSim.insert_indent"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuffEdSim.SourceBuffEdSim.insert_indent</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">code_bef</SPAN>, <SPAN CLASS="Argument">code_after</SPAN>, <SPAN CLASS="Argument">range=None</SPAN>)<SPAN CLASS="OneLiner"> # Insert code into source buffer and indent it.</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuffEdSim.SourceBuffEdSim.len</SPAN>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#SourceBuffEdSim.SourceBuffEdSim.line_num_of"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuffEdSim.SourceBuffEdSim.line_num_of</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">position=None</SPAN>)<SPAN CLASS="OneLiner"> # Returns the line number for a particular cursor position</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuffEdSim.SourceBuffEdSim.lines_around_cursor"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuffEdSim.SourceBuffEdSim.lines_around_cursor</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # Returns the line numbers of lines around cursor</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuffEdSim.SourceBuffEdSim.print_buff"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuffEdSim.SourceBuffEdSim.print_buff</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">from_line=None</SPAN>, <SPAN CLASS="Argument">to_line=None</SPAN>)<SPAN CLASS="OneLiner"> # Prints buffer to STDOUT</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuffEdSim.SourceBuffEdSim.search_for"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuffEdSim.SourceBuffEdSim.search_for</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">regexp</SPAN>, <SPAN CLASS="Argument">direction=1</SPAN>, <SPAN CLASS="Argument">num=1</SPAN>, <SPAN CLASS="Argument">where=1</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuffEdSim.SourceBuffEdSim.set_selection</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">range</SPAN>, <SPAN CLASS="Argument">cursor_at=1</SPAN>)

    <SPAN CLASS="InheritsHead"># Inherited from Object.Object</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">**args_super</SPAN>)
    <A CLASS="DocLink" HREF="#Object.Object.decl_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.decl_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)<SPAN CLASS="OneLiner"> # Define new attributes for <EM>self</EM></SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.deep_construct"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.deep_construct</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">this_class</SPAN>, <SPAN CLASS="Argument">attrs_this_class</SPAN>, <SPAN CLASS="Argument">args_super</SPAN>, <SPAN CLASS="Argument">new_default={}</SPAN>, <SPAN CLASS="Argument">enforce_value={}</SPAN>, <SPAN CLASS="Argument">exclude_bases={}</SPAN>)<SPAN CLASS="OneLiner"> # Build an instance of a class.</SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.init_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.init_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)<SPAN CLASS="OneLiner"> # Initialises existing attributes</SPAN>

    <SPAN CLASS="InheritsHead"># Inherited from SourceBuff.SourceBuff</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">app</SPAN>, <SPAN CLASS="Argument">file_name=None</SPAN>, <SPAN CLASS="Argument">language=None</SPAN>, <SPAN CLASS="Argument">**attrs</SPAN>)
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.bidirectional_selection"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.bidirectional_selection</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # does editor support selections with cursor at left?</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.contents"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.contents</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # retrieves entire contents of the buffer</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.cur_pos"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.cur_pos</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.delete"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.delete</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">range=None</SPAN>)<SPAN CLASS="OneLiner"> # Delete text in a source buffer range.</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.distance_to_selection"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.distance_to_selection</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">start</SPAN>, <SPAN CLASS="Argument">*opt_end</SPAN>)<SPAN CLASS="OneLiner"> # Computes the distance of a region to the current selection.</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.get_selection"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.get_selection</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.get_text"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.get_text</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">start=None</SPAN>, <SPAN CLASS="Argument">end=None</SPAN>)<SPAN CLASS="OneLiner"> # retrieves a portion of the buffer</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.get_visible"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.get_visible</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.goto"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.goto</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">pos</SPAN>)
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.goto_end_of_selection"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.goto_end_of_selection</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">end=1</SPAN>)
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.goto_line"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.goto_line</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">linenum</SPAN>, <SPAN CLASS="Argument">where=-1</SPAN>)<SPAN CLASS="OneLiner"> # Go to a particular line in a buffer.</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.indent"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.indent</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">range=None</SPAN>)<SPAN CLASS="OneLiner"> # Indent code in a source buffer region.</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.insert"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.insert</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">text</SPAN>, <SPAN CLASS="Argument">range=None</SPAN>)
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.insert_indent"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.insert_indent</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">code_bef</SPAN>, <SPAN CLASS="Argument">code_after</SPAN>, <SPAN CLASS="Argument">range=None</SPAN>)<SPAN CLASS="OneLiner"> # Insert code into source buffer and indent it.</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.is_language"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.is_language</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">lang</SPAN>)<SPAN CLASS="OneLiner"> # Check if a source buffer is in a particular language.</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.language_name"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.language_name</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">file_name</SPAN>)<SPAN CLASS="OneLiner"> # Returns the name of the language a file is written in</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.len"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.len</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # return length of buffer in characters.</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.line_num_of"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.line_num_of</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">position=None</SPAN>)
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.make_position_visible"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.make_position_visible</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">position=None</SPAN>)
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.make_valid_range"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.make_valid_range</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">range</SPAN>)<SPAN CLASS="OneLiner"> # Makes sure a region is increasing and within the buffer's range.</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.make_within_range"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.make_within_range</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">position</SPAN>)<SPAN CLASS="OneLiner"> # Makes sure a position is within the buffer's range.</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.move_relative"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.move_relative</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">rel_movement</SPAN>)<SPAN CLASS="OneLiner"> # Move cursor to plus or minus a certain number of characters</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.number_lines"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.number_lines</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">astring</SPAN>, <SPAN CLASS="Argument">startnum=1</SPAN>)<SPAN CLASS="OneLiner"> # Assign numbers to lines in a string.</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.refresh</SPAN>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # Force a refresh of the buffer</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.refresh_if_needed</SPAN>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # Refresh buffer if necessary</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.region_distance"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.region_distance</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">region1_start</SPAN>, <SPAN CLASS="Argument">region1_end</SPAN>, <SPAN CLASS="Argument">region2_start</SPAN>, <SPAN CLASS="Argument">region2_end</SPAN>)<SPAN CLASS="OneLiner"> # Computes the distance between two regions of text</SPAN>
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.search_for"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.search_for</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">regexp</SPAN>, <SPAN CLASS="Argument">direction=1</SPAN>, <SPAN CLASS="Argument">num=1</SPAN>, <SPAN CLASS="Argument">where=1</SPAN>)
    <A CLASS="DocLink" HREF="#SourceBuff.SourceBuff.set_selection"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SourceBuff.SourceBuff.set_selection</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">range</SPAN>, <SPAN CLASS="Argument">cursor_at=1</SPAN>)

</PRE><H2>Description</H2><P>
concrete class representing a disconnected source buffer for the
editor simulator EdSim.</P>
<P>
<STRONG>INSTANCE ATTRIBUTES</STRONG></P>

<DL>

<DT>
<EM>INT pos=0</EM>
<DD>Cursor position (in number of chars) in the buffer
<DT>
<EM>(INT, INT)</EM> visible_range
<DD>the visible portion of the source buffer as
  character offsets into contents.
<DT>
<EM>(INT, INT)</EM> selection_range
<DD>the current selection as
  character offsets into contents.
<DT>
<EM>STR content=None</EM>
<DD>Content of the source buffer
</DL>
<P>
CLASS ATTRIBUTES**</P>
<P>
<EM>none</EM>
</P>
<H2 ID="SourceBuffEdSim.SourceBuffEdSim.delete" CLASS="Method">SourceBuffEdSim.SourceBuffEdSim.delete(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">range=None</SPAN>)</H2>
<P>Delete text in a source buffer range.</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>(INT, INT)</EM> range
<DD>code range to be deleted.  If None,
defaults to the current selection.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="SourceBuffEdSim.SourceBuffEdSim.goto" CLASS="Method">SourceBuffEdSim.SourceBuffEdSim.goto(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">pos</SPAN>)</H2>
<P>None</P>

<P>
Moves the cursor to position <EM>INT pos</EM> of source buffer
(and make selection empty) 
</P>
<H2 ID="SourceBuffEdSim.SourceBuffEdSim.goto_line" CLASS="Method">SourceBuffEdSim.SourceBuffEdSim.goto_line(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">linenum</SPAN>, <SPAN CLASS="Argument">where=-1</SPAN>)</H2>
<P>Go to a particular line in a buffer.</P>

<P>
<EM>INT linenum</EM> is the line number.</P>
<P>
<EM>INT where</EM> indicates if the cursor should go at the end
 (*where &gt; 0*) or at the beginning (*where &lt; 0*) of the line.
</P>
<H2 ID="SourceBuffEdSim.SourceBuffEdSim.indent" CLASS="Method">SourceBuffEdSim.SourceBuffEdSim.indent(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">range=None</SPAN>)</H2>
<P>Indent code in a source buffer region.</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>(INT, INT)</EM> range
<DD>code range to be replaced.  If None,
defaults to the current selection.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="SourceBuffEdSim.SourceBuffEdSim.insert" CLASS="Method">SourceBuffEdSim.SourceBuffEdSim.insert(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">text</SPAN>, <SPAN CLASS="Argument">range=None</SPAN>)</H2>
<P>None</P>

<P>
Replace text in range with 
with text</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR text</EM>
<DD>new text
<DT>
<EM>(INT, INT)</EM> range
<DD>code range to be replaced.  If None,
defaults to the current selection.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="SourceBuffEdSim.SourceBuffEdSim.insert_indent" CLASS="Method">SourceBuffEdSim.SourceBuffEdSim.insert_indent(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">code_bef</SPAN>, <SPAN CLASS="Argument">code_after</SPAN>, <SPAN CLASS="Argument">range=None</SPAN>)</H2>
<P>Insert code into source buffer and indent it.</P>

<P>
Replace code in range 
with the concatenation of
code <EM>STR code_bef</EM> and <EM>str code_after</EM>. Cursor is put right
after code <EM>STR bef</EM>.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> code_bef
<DD>code to be inserted before new cursor location
<DT>
<EM>STR</EM> code_bef
<DD>code to be inserted after new cursor location
<DT>
<EM>(INT, INT)</EM> range
<DD>code range to be replaced.  If None,
defaults to the current selection.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="SourceBuffEdSim.SourceBuffEdSim.line_num_of" CLASS="Method">SourceBuffEdSim.SourceBuffEdSim.line_num_of(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">position=None</SPAN>)</H2>
<P>Returns the line number for a particular cursor position</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>INT</EM> position
<DD>The position.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>INT line_num</EM>
<DD>The line number of that position

</DL>
<H2 ID="SourceBuffEdSim.SourceBuffEdSim.lines_around_cursor" CLASS="Method">SourceBuffEdSim.SourceBuffEdSim.lines_around_cursor(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>Returns the line numbers of lines around cursor</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>(INT from_line, INT to_line)</EM></P>

<DL>

<DT>
<EM>INT from_line</EM>
<DD>First line of the window.
<DT>
<EM>INT to_line</EM>
<DD>Last line of the window.

</DL>
<H2 ID="SourceBuffEdSim.SourceBuffEdSim.print_buff" CLASS="Method">SourceBuffEdSim.SourceBuffEdSim.print_buff(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">from_line=None</SPAN>, <SPAN CLASS="Argument">to_line=None</SPAN>)</H2>
<P>Prints buffer to STDOUT</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>INT</EM> from_line = None
<DD>First line to be printed. If <EM>None</EM>, then
print <EM>print_window_size</EM> lines around cursor.
<DT>
<EM>INT</EM> to_line = None
<DD>Last line to be printed.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="SourceBuffEdSim.SourceBuffEdSim.search_for" CLASS="Method">SourceBuffEdSim.SourceBuffEdSim.search_for(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">regexp</SPAN>, <SPAN CLASS="Argument">direction=1</SPAN>, <SPAN CLASS="Argument">num=1</SPAN>, <SPAN CLASS="Argument">where=1</SPAN>)</H2>
<P>None</P>

<P>
Moves cursor to the next occurence of regular expression
<EM>STR regexp</EM> </P>

<DL>

<DT>
<EM>INT</EM> direction
<DD>if positive, search forward, otherwise
 search backward
<DT>
<EM>INT</EM> num
<DD>number of occurences to search for
<DT>
<EM>INT</EM> where
<DD>if positive, move cursor after the occurence,
otherwise move it before
</DL>

<H3>Returns <EM>None</EM> if no occurence was found. Otherwise,
returns a match object.</H3>
        <H2 ID="Object.Object.decl_attrs" CLASS="Method">Object.Object.decl_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>Define new attributes for <EM>self</EM></P>

Attributes are directly through self.__dict__, thus bypassing safe
__setattr__.<STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 initial values as the values.
</DL>
<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="Object.Object.deep_construct" CLASS="Method">Object.Object.deep_construct(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">this_class</SPAN>, <SPAN CLASS="Argument">attrs_this_class</SPAN>, <SPAN CLASS="Argument">args_super</SPAN>, <SPAN CLASS="Argument">new_default={}</SPAN>, <SPAN CLASS="Argument">enforce_value={}</SPAN>, <SPAN CLASS="Argument">exclude_bases={}</SPAN>)</H2>
<P>Build an instance of a class.</P>

Basically, this method:
- declares and initialise all attributes listed in <EM>attrs_this_class</EM>
- invokes the <EM>__init__</EM> of all superclasses (with the exclusion of those listed in *exclude_bases*), passing them arguments in <EM>args_super</EM>
<DL>

<DT>
<EM>CLASS</EM> this_class
<DD>Class that we want to build. This is a
 class object as opposed to the name of a class. Constructors
 of immediate superclasses of <EM>this_class</EM> are called
 automatically, except if they are listed in *{CLASS: 1}
 exclude_bases*.
<DT>
<EM>{STR: ANY}</EM> attrs_this_class
<DD>New attributes (and their
 values) defined by class <EM>this_class</EM>. The keys are the names
 of the attributes and the values are the values of the
 attributes (either default values or values passed to
 *this_class.__init__*). An attribute with the appropriate
 name will be declared automatically and initialsed to the
 value specified in <EM>attrs_this_class</EM>.
<DT>
<EM>{STR: ANY}</EM> args_super
<DD>Arguments received by
<EM>this_class.__init__</EM> but not recognised by it. These are
assumed to be arguments defined in the <EM>__init__</EM> of some
ancestor class and are just passed up the construction
chain. Keys of <EM>args_super</EM> correspond to the names of the
arguments and the values corresponds to the values received
for them by <EM>this_class.__init__</EM>
<DT>
<EM>{STR: ANY}</EM> new_default={}
<DD>Used to change the default
 value of an ancestor constructor argument. In other words, if
 <EM>this_class.__init__</EM> was called without specifying a value
 for an argument that's listed in <EM>new_default</EM>, the default
 value defined in <EM>new_default</EM> will be used instead of
 whatever default might be defined in the constructor
 of an ancestor class. However, if the constructor was called
 WITH a specific value for that argument, that specific value
 will be used instead of both the defaults defined in
 <EM>new_default</EM> and the constructor of ancestor classes. Keys
 of <EM>new_default</EM> correspond to argument names, and values
 correspond to the new default values. If you don't specify a
 value of <EM>new_default</EM>, it defaults to <EM>{}</EM>, which means that
 the defaults of none of the ancestor constructor arguments
 are redefined by <EM>this_class</EM>.
<DT>
<EM>{STR: ANY}</EM> enforce_value={}
<DD>Lists of arguments with
 enforced values. If the constructor is called with a value
 for an argument that is different from the value specified
 for it in <EM>enforce_value</EM>, then an <A HREF="Object.EnforcedConstrArg.html">EnforcedConstrArg</A>
 exception will be raised. Also, if the constructor is called
 without specifying a value for a particular argument, then
 the value defined in <EM>enforce_value</EM> (if it exists) will be
 used instead of whatever default might be defined in an
 ancestor class. Keys of <EM>enforce_value</EM> correspond to
 argument names and values correspond to the enforced
 values. If you don't specify a value for <EM>enforce_value</EM>, it
 defaults to <EM>{}</EM>, which means that <EM>this_class.__init__</EM> does
 not enforce the value of any argument.
<DT>
<EM>{CLASS: BOOL}</EM> exclude_bases
<DD>Immediate base classes whose
constructors should not be called automatically. If an
immediate superclass of <EM>this_class</EM> is listed in
<EM>exclude_bases</EM>, then we don't automatically call its
constructor. It is assumed that the programmer will call the
constructor manually in <EM>this_class.__init__</EM>. If you do not
specify a value for <EM>exclude_bases</EM>, it will default to <EM>{}</EM>,
which means that the constructor of all immediate super
classes will be called automatically.
</DL>
<H2 ID="Object.Object.init_attrs" CLASS="Method">Object.Object.init_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>Initialises existing attributes</P>

Attributes are only set if they already exist in
 <EM>self.__dict__</EM>. Otherwise, an <EM>AttributeError</EM> exception is
 raised (provided PY_DEBUG_OBJECT=1).<STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 default values as the values.
</DL>
<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="SourceBuff.SourceBuff.bidirectional_selection" CLASS="Method">SourceBuff.SourceBuff.bidirectional_selection(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>does editor support selections with cursor at left?</P>

<STRONG>INPUTS</STRONG><EM>none</EM><STRONG>OUTPUS</STRONG>
<DL>

<DT>
<EM>BOOL</EM>
<DD>true if editor allows setting the selection at the
left end of the selection
</DL>
<H2 ID="SourceBuff.SourceBuff.contents" CLASS="Method">SourceBuff.SourceBuff.contents(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>retrieves entire contents of the buffer</P>

    <STRONG>INPUTS</STRONG>    <EM>none</EM>    <STRONG>OUTPUTS</STRONG>    <EM>STR</EM> contents 
    <H2 ID="SourceBuff.SourceBuff.cur_pos" CLASS="Method">SourceBuff.SourceBuff.cur_pos(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

retrieves current position of cursor .  Note: the current
position should coincide with either the start or end of the
selection.  <STRONG>INPUTS</STRONG><EM>none</EM><STRONG>OUTPUTS</STRONG>
<DL>

<DT>
<EM>INT</EM> pos
<DD>offset into buffer of current cursor position

</DL>
<H2 ID="SourceBuff.SourceBuff.delete" CLASS="Method">SourceBuff.SourceBuff.delete(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">range=None</SPAN>)</H2>
<P>Delete text in a source buffer range.</P>

<STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>(INT, INT)</EM> range
<DD>code range to be deleted.  If None,
defaults to the current selection.
</DL>
<STRONG>OUTPUTS</STRONG><EM>none</EM>
<H2 ID="SourceBuff.SourceBuff.distance_to_selection" CLASS="Method">SourceBuff.SourceBuff.distance_to_selection(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">start</SPAN>, <SPAN CLASS="Argument">*opt_end</SPAN>)</H2>
<P>Computes the distance of a region to the current selection.</P>

<STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>INT</EM> start
<DD>start position of region
<DT>
<EM>[INT]</EM> *opt_end
<DD>end position of region (optional)
</DL>
<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
<EM>INT</EM>
<DD>the distance

</DL>
<H2 ID="SourceBuff.SourceBuff.get_selection" CLASS="Method">SourceBuff.SourceBuff.get_selection(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

retrieves range of current selection.  Note: the current
position should coincide with either the start or end of the
selection. <STRONG>INPUTS</STRONG><EM>none</EM><STRONG>OUTPUTS</STRONG><EM>INT</EM> (start, end)start is the offset into the buffer of the start of the current
selection.  end is the offset into the buffer of the character 
following the selection (this matches Python's slice convention).
<H2 ID="SourceBuff.SourceBuff.get_text" CLASS="Method">SourceBuff.SourceBuff.get_text(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">start=None</SPAN>, <SPAN CLASS="Argument">end=None</SPAN>)</H2>
<P>retrieves a portion of the buffer</P>

<STRONG>INPUTS</STRONG><EM>INT start</EM> is the start of the region returned.
Defaults to start of buffer.<EM>INT end</EM> is the offset into the buffer of the character following 
the region to be returned (this matches Python's slice convention).
Defaults to end of buffer.<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
<EM>STR</EM>
<DD>contents of specified range of the buffer

</DL>
<H2 ID="SourceBuff.SourceBuff.get_visible" CLASS="Method">SourceBuff.SourceBuff.get_visible(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

 get start and end offsets of the currently visible region of
the buffer.  End is the offset of the first character not
visible (matching Python's slice convention)<STRONG>INPUTS</STRONG><EM>none</EM><STRONG>OUTPUTS</STRONG><EM>INT</EM> (start, end)
<H2 ID="SourceBuff.SourceBuff.goto" CLASS="Method">SourceBuff.SourceBuff.goto(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">pos</SPAN>)</H2>
<P>None</P>

Moves the cursor to position <EM>INT pos</EM> of source buffer
(and make selection empty)If <EM>f_name</EM> is <EM>None</EM>, use [self.curr_buffer].<H2 ID="SourceBuff.SourceBuff.goto_end_of_selection" CLASS="Method">SourceBuff.SourceBuff.goto_end_of_selection(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">end=1</SPAN>)</H2>
<P>None</P>

moves cursor to one end of the selection, clearing the
selection.<STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>INT</EM> end
<DD>left (0) or right (1) end of selection
</DL>
<STRONG>OUTPUT</STRONG><EM>none</EM>
<H2 ID="SourceBuff.SourceBuff.goto_line" CLASS="Method">SourceBuff.SourceBuff.goto_line(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">linenum</SPAN>, <SPAN CLASS="Argument">where=-1</SPAN>)</H2>
<P>Go to a particular line in a buffer.</P>

<EM>INT linenum</EM> is the line number.<EM>INT where</EM> indicates if the cursor should go at the end
 (*where &gt; 0*) or at the beginning (*where &lt; 0*) of the line.
<H2 ID="SourceBuff.SourceBuff.indent" CLASS="Method">SourceBuff.SourceBuff.indent(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">range=None</SPAN>)</H2>
<P>Indent code in a source buffer region.</P>

<STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>(INT, INT)</EM> range
<DD>code range to be replaced.  If None,
defaults to the current selection.
</DL>
<STRONG>OUTPUTS</STRONG><EM>none</EM>
<H2 ID="SourceBuff.SourceBuff.insert" CLASS="Method">SourceBuff.SourceBuff.insert(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">text</SPAN>, <SPAN CLASS="Argument">range=None</SPAN>)</H2>
<P>None</P>

Replace text in range with 
with text<STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>STR text</EM>
<DD>new text
<DT>
<EM>(INT, INT)</EM> range
<DD>code range to be replaced.  If None,
defaults to the current selection.
</DL>
<STRONG>OUTPUTS</STRONG><EM>none</EM>
<H2 ID="SourceBuff.SourceBuff.insert_indent" CLASS="Method">SourceBuff.SourceBuff.insert_indent(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">code_bef</SPAN>, <SPAN CLASS="Argument">code_after</SPAN>, <SPAN CLASS="Argument">range=None</SPAN>)</H2>
<P>Insert code into source buffer and indent it.</P>

Replace code in range 
with the concatenation of
code <EM>STR code_bef</EM> and <EM>str code_after</EM>. Cursor is put right
after code <EM>STR bef</EM>.<STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>STR</EM> code_bef
<DD>code to be inserted before new cursor location
<DT>
<EM>STR</EM> code_bef
<DD>code to be inserted after new cursor location
<DT>
<EM>(INT, INT)</EM> range
<DD>code range to be replaced.  If None,
defaults to the current selection.
</DL>
<STRONG>OUTPUTS</STRONG><EM>none</EM>
<H2 ID="SourceBuff.SourceBuff.is_language" CLASS="Method">SourceBuff.SourceBuff.is_language(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">lang</SPAN>)</H2>
<P>Check if a source buffer is in a particular language.</P>

Outputs <EM>true</EM> if and only if <EM>self</EM> is displaying a file
written in programming language <EM>STR lang</EM>.
<H2 ID="SourceBuff.SourceBuff.language_name" CLASS="Method">SourceBuff.SourceBuff.language_name(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">file_name</SPAN>)</H2>
<P>Returns the name of the language a file is written in</P>

<STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>STR</EM> file_name
<DD>name of the file 
</DL>
<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
<EM>STR</EM>
<DD>the name of the language

</DL>
<H2 ID="SourceBuff.SourceBuff.len" CLASS="Method">SourceBuff.SourceBuff.len(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>return length of buffer in characters.</P>

<STRONG>INPUTS</STRONG><EM>none</EM><STRONG>OUTPUTS</STRONG><EM>INT</EM> length 
<H2 ID="SourceBuff.SourceBuff.line_num_of" CLASS="Method">SourceBuff.SourceBuff.line_num_of(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">position=None</SPAN>)</H2>
<P>None</P>


Returns the line number for a particular cursor position<STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>INT</EM> position
<DD>The position.  (defaults to the current position)
</DL>
<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
<EM>INT line_num</EM>
<DD>The line number of that position

</DL>
<H2 ID="SourceBuff.SourceBuff.make_position_visible" CLASS="Method">SourceBuff.SourceBuff.make_position_visible(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">position=None</SPAN>)</H2>
<P>None</P>

scroll buffer (if necessary) so that  the specified position
is visible<STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>INT</EM> position
<DD>position to make visible (defaults to the
current position)
</DL>
<STRONG>OUTPUTS</STRONG><EM>none</EM>
<H2 ID="SourceBuff.SourceBuff.make_valid_range" CLASS="Method">SourceBuff.SourceBuff.make_valid_range(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">range</SPAN>)</H2>
<P>Makes sure a region is increasing and within the buffer's range.</P>

<STRONG>INPUTS</STRONG> 
<DL>

<DT>
<EM>(INT, INT)</EM> range
<DD>offsets of initial range
</DL>
<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
<EM>(INT, INT)</EM>
<DD>increasing range within bounds

</DL>
<H2 ID="SourceBuff.SourceBuff.make_within_range" CLASS="Method">SourceBuff.SourceBuff.make_within_range(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">position</SPAN>)</H2>
<P>Makes sure a position is within the buffer's range.</P>

<STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>INT</EM> position
<DD>The position. If outside of bounds, bring it back
to the first or last position of the buffer.
</DL>
<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
<EM>INT</EM> position
<DD>The possibly corrected position

</DL>
<H2 ID="SourceBuff.SourceBuff.move_relative" CLASS="Method">SourceBuff.SourceBuff.move_relative(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">rel_movement</SPAN>)</H2>
<P>Move cursor to plus or minus a certain number of characters</P>

<STRONG>INPUTS</STRONG> 
<DL>

<DT>
<EM>INT rel_movement</EM>
<DD>number of characters to move, relative to 
current position.  If &lt; 0 then move to the left. Otherwise, move to the
right.
</DL>
<STRONG>OUTPUTS</STRONG><EM>none</EM>
<H2 ID="SourceBuff.SourceBuff.number_lines" CLASS="Method">SourceBuff.SourceBuff.number_lines(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">astring</SPAN>, <SPAN CLASS="Argument">startnum=1</SPAN>)</H2>
<P>Assign numbers to lines in a string.</P>

<EM>STR astring</EM> is the string in question.<EM>INT startnum</EM> is the number of the first line in <EM>astring</EM>Returns a list of pairs <EM>[(INT, STR)]</EM> where first entry is
the line number and the second entry is the line.<H2 ID="SourceBuff.SourceBuff.region_distance" CLASS="Method">SourceBuff.SourceBuff.region_distance(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">region1_start</SPAN>, <SPAN CLASS="Argument">region1_end</SPAN>, <SPAN CLASS="Argument">region2_start</SPAN>, <SPAN CLASS="Argument">region2_end</SPAN>)</H2>
<P>Computes the distance between two regions of text</P>

<STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>INT</EM> region1_start
<DD>start position of first region
<DT>
<EM>INT</EM> region1_end
<DD>end position of first region
<DT>
<EM>INT</EM> region2_start
<DD>start position of 2nd region
<DT>
<EM>INT</EM> region2_end
<DD>end position of 2nd region
</DL>
<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
<EM>INT</EM> distance
<DD>distnace between the two regions of text

</DL>
<H2 ID="SourceBuff.SourceBuff.search_for" CLASS="Method">SourceBuff.SourceBuff.search_for(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">regexp</SPAN>, <SPAN CLASS="Argument">direction=1</SPAN>, <SPAN CLASS="Argument">num=1</SPAN>, <SPAN CLASS="Argument">where=1</SPAN>)</H2>
<P>None</P>

Moves cursor to the next occurence of regular expression
<EM>STR regexp</EM> in buffer with file name <EM>STR f_name</EM>.
<DL>

<DT>
<EM>INT</EM> direction
<DD>if positive, search forward, otherwise
 search backward
<DT>
<EM>INT</EM> num
<DD>number of occurences to search for
<DT>
<EM>INT</EM> where
<DD>if positive, move cursor after the occurence,
otherwise move it before
<DT>
<EM>STR</EM> f_name
<DD>name of the file in buffer where the search
 should be done. If <EM>None</EM>, use [self.curr_buffer].
</DL>
Returns <EM>None</EM> if no occurence was found. Otherwise,
returns a match object.
        .. [self.curr_buffer] AppState.AppState.html<H2 ID="SourceBuff.SourceBuff.set_selection" CLASS="Method">SourceBuff.SourceBuff.set_selection(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">range</SPAN>, <SPAN CLASS="Argument">cursor_at=1</SPAN>)</H2>
<P>None</P>

sets range of current selection, and sets the position to 
beginning or end of the selection.<STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>(INT, INT)</EM> range
<DD>offsets into buffer of the start and end
of the selection.  end is the offset into the buffer of the character 
following the selection (this matches Python's slice convention).
<DT>
<EM>INT</EM> cursor_at
<DD>indicates whether the cursor should be
placed at the left (0) or right (1) end of the selection.  Note:
cursor_at is ignored unless the application supports this
choice, as indicated by bidirectional_selection.  
Most Windows applications do not.
</DL>
<STRONG>OUTPUTS</STRONG><EM>none</EM>

<HR>
<TABLE ALIGN="LEFT">
<TR><TD>
  <A HREF="http://validator.w3.org/check/referer" TARGET="validate">
    <IMG BORDER=0 SRC="http://validator.w3.org/images/vh40.gif"
     ALT="Valid HTML 4.0!" HEIGHT=31 WIDTH=88></A>
  <A HREF="http://www.w3.org/Style/CSS/Buttons">
    <IMG ALT="Made with CSS" BORDER=0 WIDTH=88 HEIGHT=31 
     SRC="http://www.w3.org/Style/CSS/Buttons/mwcos"></A>

</TD>
<TD STYLE="padding-left: 10">
  <SPAN CLASS="AUTHOR"></SPAN><BR>
  <SPAN CLASS="VERSION"></SPAN>
</TD>
</TABLE>

</body>
</html>
