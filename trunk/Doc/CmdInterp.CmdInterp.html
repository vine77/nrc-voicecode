<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>

<head>

<META NAME="GENERATOR" CONTENT="pythondoc 0.7 (Tue Oct 03 16:08:01 2000)">

<link rel="stylesheet" href="pythondoc.css" type="text/css">

<title>Class CmdInterp</title>
</head>

<body>
<P><A HREF="index.html">Table of contents</A> <A HREF="indices.html">Index</A></P>


<H1 CLASS="ClassName">class CmdInterp - Interprets Context Sensitive Commands spoken into a given application.</H1>
<P CLASS="DeclaredIn">Declared in module <A HREF="CmdInterp.html">CmdInterp</A></P>

<H2 CLASS="ClassHierarchy">Inheritance hierarchy:</H2><P CLASS="ClassHierarchy">CmdInterp.CmdInterp<BR>
&nbsp;&nbsp;Object.Object<BR>
</P>

<H2>Synopsis</H2>
<PRE CLASS="ClassDeclaration">
<SPAN CLASS="PyKeyword">class</SPAN> <SPAN CLASS="ClassName">CmdInterp</SPAN>(<A CLASS="DocLink" HREF="Object.Object.html">Object</A>):
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">CmdInterp.CmdInterp.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">on_app=None</SPAN>, <SPAN CLASS="Argument">**attrs</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">CmdInterp.CmdInterp.all_cmds_regexp</SPAN>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # Returns a regexp that matches the spoken form of all voice commands</SPAN>
    <A CLASS="DocLink" HREF="#CmdInterp.CmdInterp.choose_best_symbol"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">CmdInterp.CmdInterp.choose_best_symbol</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">spoken_form</SPAN>, <SPAN CLASS="Argument">choices</SPAN>)<SPAN CLASS="OneLiner"> # Chooses the best match for a spoken form of a symbol.</SPAN>
    <A CLASS="DocLink" HREF="#CmdInterp.CmdInterp.chop_symbol"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">CmdInterp.CmdInterp.chop_symbol</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">command</SPAN>)<SPAN CLASS="OneLiner"> # Chops off the beginning of a string if it matches a known symbol.</SPAN>
    <A CLASS="DocLink" HREF="#CmdInterp.CmdInterp.index_csc"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">CmdInterp.CmdInterp.index_csc</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">acmd</SPAN>, <SPAN CLASS="Argument">add_voc_entry=1</SPAN>)<SPAN CLASS="OneLiner"> # Add a new csc to the command interpreter's command dictionary</SPAN>
    <A CLASS="DocLink" HREF="#CmdInterp.CmdInterp.interpret_NL_cmd"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">CmdInterp.CmdInterp.interpret_NL_cmd</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">cmd</SPAN>)
    <A CLASS="DocLink" HREF="#CmdInterp.CmdInterp.load_language_specific_aliases"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">CmdInterp.CmdInterp.load_language_specific_aliases</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#CmdInterp.CmdInterp.spoken_form_regexp"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">CmdInterp.CmdInterp.spoken_form_regexp</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">spoken_form</SPAN>)<SPAN CLASS="OneLiner"> # Returns a regexp that matches a spoken form of a command.</SPAN>

    <SPAN CLASS="InheritsHead"># Inherited from Object.Object</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">**args_super</SPAN>)
    <A CLASS="DocLink" HREF="#Object.Object.decl_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.decl_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)<SPAN CLASS="OneLiner"> # Define new attributes for <EM>self</EM></SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.deep_construct"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.deep_construct</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">this_class</SPAN>, <SPAN CLASS="Argument">attrs_this_class</SPAN>, <SPAN CLASS="Argument">args_super</SPAN>, <SPAN CLASS="Argument">new_default={}</SPAN>, <SPAN CLASS="Argument">enforce_value={}</SPAN>, <SPAN CLASS="Argument">exclude_bases={}</SPAN>)<SPAN CLASS="OneLiner"> # Build an instance of a class.</SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.init_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.init_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)<SPAN CLASS="OneLiner"> # Initialises existing attributes</SPAN>

</PRE><H2>Description</H2><P>
<STRONG>INSTANCE ATTRIBUTES</STRONG></P>

<DL>

<DT>
<A HREF="AppState.AppState.html">AppState</A> <EM>on_app=None</EM>
<DD>application for which we are
interpreting the commands
<DT>
<EM>{STR: [[</EM> (Context] <EM>, FCT)]} cmd_index={}</EM>
<DD>index of CSCs. Key
 is the spoken form of the command, value is a list of contextual
 meanings. A contextual meaning is a pair of a <EM>context object</EM>
 and an <EM>action function</EM> to be fired if the context applies.
<DT>
<A HREF="SymDict.SymDict.html">SymDict</A> known_symbols
<DD>dictionary of known symbols
<DT>
<EM>STR cached_regexp=''</EM>
<DD>Regular expresion that matches the
 spoken form of any of the CSCs.
<DT>
<EM>BOOL cached_regexp_is_dirty</EM>
<DD><EM>true</EM> iif <EM>self.cached_regexp</EM> needs
 to be regenerated based on the values in <EM>self.cmd_index</EM>
<DT>
<EM>{STR: [STR]}</EM> language_specific_aliases = {}
<DD>Key is the name of
 a programming language (None means all languages). Value is a
 list of written form\spoken form words specific to a
 language. These words are loaded automatically when we are in a
 source buffer of that language and removed when we change to a
 buffer in a different language.
<DT>
<EM>STR</EM> last_loaded_language = None
<DD>Name of the previous language
 for which the language specific words were loaded.   
</DL>
<P>
CLASS ATTRIBUTES**</P>
<P>
<EM>none</EM> --</P>
<H2 ID="CmdInterp.CmdInterp.choose_best_symbol" CLASS="Method">CmdInterp.CmdInterp.choose_best_symbol(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">spoken_form</SPAN>, <SPAN CLASS="Argument">choices</SPAN>)</H2>
<P>Chooses the best match for a spoken form of a symbol.</P>

<P>
For now, we just choose the first item in <EM>choices</EM>, but in
the future, we might choose the one that appears closest to
the cursor, or the one that used most recently, or the one
that best matches the spoken form.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> spoken_form
<DD>spoken form of the symbol. 
<DT>
<EM>ANY</EM> choices
<DD>undocumented 
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="CmdInterp.CmdInterp.chop_symbol" CLASS="Method">CmdInterp.CmdInterp.chop_symbol(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">command</SPAN>)</H2>
<P>Chops off the beginning of a string if it matches a known symbol.</P>

<P>
If more than one symbols are possible, returns the symbol that
consumes the greateest number of words from command.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> command
<DD>the string from which we want to chop off a symbol.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
Returns a pair <EM>(best_symbol, rest)</EM> where:</P>

<DL>

<DT>
<EM>STR</EM> best_symbol
<DD>is the symbol that was chopped off (in native
 format). If <EM>None</EM>, it means <EM>command</EM> did not start with a
 symbol.
<DT>
<EM>STR</EM> rest
<DD>is what was left of <EM>command</EM> after the symbol
 was chopped off.
</DL>
<H2 ID="CmdInterp.CmdInterp.index_csc" CLASS="Method">CmdInterp.CmdInterp.index_csc(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">acmd</SPAN>, <SPAN CLASS="Argument">add_voc_entry=1</SPAN>)</H2>
<P>Add a new csc to the command interpreter's command dictionary</P>

<P>
<A HREF="CSCmd.CSCmd.html">CSCmd</A> <EM>acmd</EM> is the command to be indexed.</P>

<DL>

<DT>
<EM>BOOL add_voc_entry = 1</EM>
<DD>if true, add a SR vocabulary entry
 for the CSC's spoken forms
</DL>
<H2 ID="CmdInterp.CmdInterp.interpret_NL_cmd" CLASS="Method">CmdInterp.CmdInterp.interpret_NL_cmd(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">cmd</SPAN>)</H2>
<P>None</P>

<P>
Interprets a natural language command and executes
corresponding instructions.</P>
<P>
<EM>STR cmd</EM> is the spoken form of the command.
</P>
<H2 ID="CmdInterp.CmdInterp.load_language_specific_aliases" CLASS="Method">CmdInterp.CmdInterp.load_language_specific_aliases(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
Loads words specific to the language of the current buffer,
if needed.</P>
<P>
Also, unloads words specific to previously loaded language if needed.</P>
<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="CmdInterp.CmdInterp.spoken_form_regexp" CLASS="Method">CmdInterp.CmdInterp.spoken_form_regexp(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">spoken_form</SPAN>)</H2>
<P>Returns a regexp that matches a spoken form of a command.</P>

<P>
<EM>STR spoken_form</EM> is the spoken form. The returned regexp will match
it even if the case of the first letter of each word do not match.</P>
<H2 ID="Object.Object.decl_attrs" CLASS="Method">Object.Object.decl_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>Define new attributes for <EM>self</EM></P>

<P>
Attributes are directly through self.__dict__, thus bypassing safe
__setattr__.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 initial values as the values.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="Object.Object.deep_construct" CLASS="Method">Object.Object.deep_construct(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">this_class</SPAN>, <SPAN CLASS="Argument">attrs_this_class</SPAN>, <SPAN CLASS="Argument">args_super</SPAN>, <SPAN CLASS="Argument">new_default={}</SPAN>, <SPAN CLASS="Argument">enforce_value={}</SPAN>, <SPAN CLASS="Argument">exclude_bases={}</SPAN>)</H2>
<P>Build an instance of a class.</P>

<P>
Basically, this method:
- declares and initialise all attributes listed in <EM>attrs_this_class</EM>
- invokes the <EM>__init__</EM> of all superclasses (with the exclusion of those listed in *exclude_bases*), passing them arguments in <EM>args_super</EM></P>

<DL>

<DT>
<EM>CLASS</EM> this_class
<DD>Class that we want to build. This is a
 class object as opposed to the name of a class. Constructors
 of immediate superclasses of <EM>this_class</EM> are called
 automatically, except if they are listed in *{CLASS: 1}
 exclude_bases*.
<DT>
<EM>{STR: ANY}</EM> attrs_this_class
<DD>New attributes (and their
 values) defined by class <EM>this_class</EM>. The keys are the names
 of the attributes and the values are the values of the
 attributes (either default values or values passed to
 *this_class.__init__*). An attribute with the appropriate
 name will be declared automatically and initialsed to the
 value specified in <EM>attrs_this_class</EM>.
<DT>
<EM>{STR: ANY}</EM> args_super
<DD>Arguments received by
<EM>this_class.__init__</EM> but not recognised by it. These are
assumed to be arguments defined in the <EM>__init__</EM> of some
ancestor class and are just passed up the construction
chain. Keys of <EM>args_super</EM> correspond to the names of the
arguments and the values corresponds to the values received
for them by <EM>this_class.__init__</EM>
<DT>
<EM>{STR: ANY}</EM> new_default={}
<DD>Used to change the default
 value of an ancestor constructor argument. In other words, if
 <EM>this_class.__init__</EM> was called without specifying a value
 for an argument that's listed in <EM>new_default</EM>, the default
 value defined in <EM>new_default</EM> will be used instead of
 whatever default might be defined in the constructor
 of an ancestor class. However, if the constructor was called
 WITH a specific value for that argument, that specific value
 will be used instead of both the defaults defined in
 <EM>new_default</EM> and the constructor of ancestor classes. Keys
 of <EM>new_default</EM> correspond to argument names, and values
 correspond to the new default values. If you don't specify a
 value of <EM>new_default</EM>, it defaults to <EM>{}</EM>, which means that
 the defaults of none of the ancestor constructor arguments
 are redefined by <EM>this_class</EM>.
<DT>
<EM>{STR: ANY}</EM> enforce_value={}
<DD>Lists of arguments with
 enforced values. If the constructor is called with a value
 for an argument that is different from the value specified
 for it in <EM>enforce_value</EM>, then an <A HREF="Object.EnforcedConstrArg.html">EnforcedConstrArg</A>
 exception will be raised. Also, if the constructor is called
 without specifying a value for a particular argument, then
 the value defined in <EM>enforce_value</EM> (if it exists) will be
 used instead of whatever default might be defined in an
 ancestor class. Keys of <EM>enforce_value</EM> correspond to
 argument names and values correspond to the enforced
 values. If you don't specify a value for <EM>enforce_value</EM>, it
 defaults to <EM>{}</EM>, which means that <EM>this_class.__init__</EM> does
 not enforce the value of any argument.
<DT>
<EM>{CLASS: BOOL}</EM> exclude_bases
<DD>Immediate base classes whose
constructors should not be called automatically. If an
immediate superclass of <EM>this_class</EM> is listed in
<EM>exclude_bases</EM>, then we don't automatically call its
constructor. It is assumed that the programmer will call the
constructor manually in <EM>this_class.__init__</EM>. If you do not
specify a value for <EM>exclude_bases</EM>, it will default to <EM>{}</EM>,
which means that the constructor of all immediate super
classes will be called automatically.
</DL>
<H2 ID="Object.Object.init_attrs" CLASS="Method">Object.Object.init_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>Initialises existing attributes</P>

<P>
Attributes are only set if they already exist in
 <EM>self.__dict__</EM>. Otherwise, an <EM>AttributeError</EM> exception is
 raised (provided PY_DEBUG_OBJECT=1).</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 default values as the values.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>

<HR>
<TABLE ALIGN="LEFT">
<TR><TD>
  <A HREF="http://validator.w3.org/check/referer" TARGET="validate">
    <IMG BORDER=0 SRC="http://validator.w3.org/images/vh40.gif"
     ALT="Valid HTML 4.0!" HEIGHT=31 WIDTH=88></A>
  <A HREF="http://www.w3.org/Style/CSS/Buttons">
    <IMG ALT="Made with CSS" BORDER=0 WIDTH=88 HEIGHT=31 
     SRC="http://www.w3.org/Style/CSS/Buttons/mwcos"></A>

</TD>
<TD STYLE="padding-left: 10">
  <SPAN CLASS="AUTHOR"></SPAN><BR>
  <SPAN CLASS="VERSION"></SPAN>
</TD>
</TABLE>

</body>
</html>
