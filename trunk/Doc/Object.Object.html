<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>

<head>

<META NAME="GENERATOR" CONTENT="pythondoc 0.7 (Thu May 25 13:03:10 2000)">

<link rel="stylesheet" href="pythondoc.css" type="text/css">

<title>Class Object</title>
</head>

<body>
<P><A HREF="index.html">Table of contents</A> <A HREF="indices.html">Index</A></P>


<H1 CLASS="ClassName">class Object - A base class for all VoiceCode objects</H1>
<P CLASS="DeclaredIn">Declared in module <A HREF="Object.html">Object</A></P>



<H2>Synopsis</H2>
<PRE CLASS="ClassDeclaration">
<SPAN CLASS="PyKeyword">class</SPAN> <SPAN CLASS="ClassName">Object</SPAN>:
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#Object.Object.deep_construct"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.deep_construct</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">this_class</SPAN>, <SPAN CLASS="Argument">attrs_this_class</SPAN>, <SPAN CLASS="Argument">attrs_superclasses</SPAN>, <SPAN CLASS="Argument">exclude_bases={}</SPAN>)<SPAN CLASS="OneLiner"> # Build an instance of a class.</SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.init_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.init_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)<SPAN CLASS="OneLiner"> # Initialises existing attributes</SPAN>

</PRE><H2>Description</H2><P>
This class implements various useful behaviors for generic
objects, such as:</P>

<UL>

<LI>safe attribute setting

<LI>deep constructor

<LI>pretty printing???
</UL>
<P>
<STRONG>SAFE ATTRIBUTE SETTING*</STRONG></P>
<P>
When getting the value of an attribute, Python will issue an
<EM>AttributeError</EM> if that attribute doesn't exist. However, it
doesn't do that when trying to set the value of an inexistant
attribute.</P>
<P>
The [Object] class defines a safe <EM>__setattr__</EM> method, which raise an
exception when trying to set the value of an inexistant attribute.</P>
<P>
For performance reasons, these safe attribute setting methods are
only invoked if environment variable <EM>$PY_DEBUG_OBJECT=1</EM>.</P>
<P>
Note that this class does not define a safe <EM>__getattr__</EM>
method because Python already raises an exception when trying to
get the value of an inexistant attribute.</P>
<P>
Profile tests on NT indicate that:</P>

<UL>

<LI>the speed of constructors for Object and non-Object instances are the same

<LI>the speed of attribute <EM>gets</EM> is the same for Object and non-Object instances

<LI>when <EM>$PY_DEBUG_OBJECT=0</EM>, the performance of attribute <EM>sets</EM> is the same for Object and non-Object instances

<LI>when <EM>$PY_DEBUG_OBJECT=1</EM>, attribute <EM>sets</EM> are slower by a factor of about 15 for Object instances than for non-Object instances
</UL>
<P>
<STRONG>DEEP CONSTRUCTORS</STRONG></P>
<P>
By default, when constructing an instance of a class, Python does
not call the constructor of all the ancestor classes. This means
that the constructor of each class must set the values of the
attributes defined by all of its ancestors, otherwise reading the
value of an ancestor attribute (or setting it when
*PY_DEBUG_OBJECT=1*) results in an <EM>AttributeError</EM>. This also
means that subclasses cannot inherit default values of ancestor
attributes from their ancestor classes.</P>
<P>
The [Object] class defines a method [deep_construct], which can be
used to create "standard" constructors which allow you to:</P>

<UL>

<LI>automatically invoke the constructor of any superclass that has a "standard" constructor

<LI>initialise the value of any attribute (including ones defined by ancestor classe) by specifying its value as a named argument

<LI>leaving the value of any attribute (including ones defined by ancestor classe) at a consistent default value, by not specifying its value as a named argument.

<LI>inherit default attribute values from ancestor classes
</UL>
<P>
Below is a template for such a standard constructor.</P>

<H3>Example:</H3>
<PRE CLASS="Example">

<H3>   class AClass(StdClass1, ..., StdClassN, NonStdClass1, ..., NonStdClassK):
      def __init__(self, attr1=val1, ..., attrN=valN, **attrs):</H3>
         self.deep_construct(AClass, {'attr1': val1, ..., <CODE>attrN</CODE>: valN}, attrs, exclude_bases={NonStdClass1: 1, ..., NonStdClassK: 1})         &lt;Code for explicitely calling NonStdClass1.__init__, ..., NonStdClassK.__init__ with appropriate arguments&gt;         &lt;Any other initialisation that can't be done automatically
          through *self.deep_construct*&gt;</PRE>
<P>
Here, <EM>StdClass1, ..., StdClassN</EM> are "standard" classes, that is
classes that have standard constructor. The constructor of those
classes can be invoked automatically because it doesn't require
any arguments.</P>
<P>
<EM>NonStdClass1, ..., NonStdClassK</EM> are "non-standard" classes,
 i.e. classes whose constructor has some compulsory arguments. The
 constructor of those non-standard classes can therefore not be
 called automatically (which is why they are set in the
 <EM>exclude_bases</EM> argument)</P>
<P>
Attributes <EM>attr1, ..., attrN</EM> are the new attributes defined by
<EM>AClass</EM>, and <EM>val1, ..., valN</EM> are their default values.</P>
<P>
The argument *{STR: ANY} <EM>*attrs</EM> collects any named arguments fed
to the constructor which don't correspond to an attribute defined
by this class. These will be used to set the values of attributes
defined in ancestor classes.</P>
<P>
Note that the file <EM>Admin/python.el</EM> contains an Emacs macro
<EM>py-obclass</EM> which automatically types this kind of template code
for a class and its constructor</P>
<P>
<STRONG>INSTANCE ATTRIBUTE</STRONG></P>
<P>
<EM>none</EM> --</P>
<P>
<STRONG>CLASS ATTRIBUTE</STRONG></P>
<P>
<EM>none</EM> --</P>
<H2 ID="Object.Object.deep_construct" CLASS="Method">Object.Object.deep_construct(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">this_class</SPAN>, <SPAN CLASS="Argument">attrs_this_class</SPAN>, <SPAN CLASS="Argument">attrs_superclasses</SPAN>, <SPAN CLASS="Argument">exclude_bases={}</SPAN>)</H2>
<P>Build an instance of a class.</P>

<P>
Make <EM>[Object] self</EM> into an instance of class <EM>CLASS this_class</EM>.</P>
<P>
Automatically call constructors of superclasses of
<EM>this_class</EM> (except for classes listed in *{CLASS: 1}
exclude_bases*). Constructors are called with no arguments.</P>
<P>
Set attributes to the values listed in *{STR: ANY}
attrs_this_class* and <EM>{STR: ANY} attrs_cupserclasses</EM>. These
attributes are set even if they do not exist in
<EM>self.__dict__</EM>.</P>
<P>
listed in <EM>exclude_bases</EM> argument). These constructors are
called with no arguments.</P>
<P>
[Object].. file:///./Object.Object.html</P>
<H2 ID="Object.Object.init_attrs" CLASS="Method">Object.Object.init_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>Initialises existing attributes</P>

<P>
Attributes are only set if they already exist in
 <EM>self.__dict__</EM>. Otherwise, an <EM>AttributeError</EM> exception is
 raised (provided PY_DEBUG_OBJECT=1).</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 default values as the values.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>

<HR>
<TABLE ALIGN="LEFT">
<TR><TD>
  <A HREF="http://validator.w3.org/check/referer" TARGET="validate">
    <IMG BORDER=0 SRC="http://validator.w3.org/images/vh40.gif"
     ALT="Valid HTML 4.0!" HEIGHT=31 WIDTH=88></A>
  <A HREF="http://www.w3.org/Style/CSS/Buttons">
    <IMG ALT="Made with CSS" BORDER=0 WIDTH=88 HEIGHT=31 
     SRC="http://www.w3.org/Style/CSS/Buttons/mwcos"></A>

</TD>
<TD STYLE="padding-left: 10">
  <SPAN CLASS="AUTHOR"></SPAN><BR>
  <SPAN CLASS="VERSION"></SPAN>
</TD>
</TABLE>

</body>
</html>
