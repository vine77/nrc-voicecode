<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>

<head>

<META NAME="GENERATOR" CONTENT="pythondoc 0.7 (Wed Apr 03 23:01:46 2002)">

<link rel="stylesheet" href="pythondoc.css" type="text/css">

<title>Class AppStateCached</title>
</head>

<body>
<P><A HREF="index.html">Table of contents</A> <A HREF="indices.html">Index</A></P>


<H1 CLASS="ClassName">class AppStateCached</H1>
<P CLASS="DeclaredIn">Declared in module <A HREF="AppStateCached.html">AppStateCached</A></P>

<H2 CLASS="ClassHierarchy">Inheritance hierarchy:</H2><P CLASS="ClassHierarchy">AppStateCached.AppStateCached<BR>
&nbsp;&nbsp;AppState.AppState<BR>
</P>

<H2>Synopsis</H2>
<PRE CLASS="ClassDeclaration">
<SPAN CLASS="PyKeyword">class</SPAN> <SPAN CLASS="ClassName">AppStateCached</SPAN>(<A CLASS="DocLink" HREF="AppState.AppState.html">AppState</A>):
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppStateCached.AppStateCached.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">**args_super</SPAN>)
    <A CLASS="DocLink" HREF="#AppStateCached.AppStateCached.init_cache"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppStateCached.AppStateCached.init_cache</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # Initialises the cache with data obtained from external editor.</SPAN>

    <SPAN CLASS="InheritsHead"># Inherited from Object.Object</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">**args_super</SPAN>)
    <A CLASS="DocLink" HREF="#Object.Object.decl_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.decl_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)<SPAN CLASS="OneLiner"> # Define new attributes for <EM>self</EM></SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.deep_construct"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.deep_construct</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">this_class</SPAN>, <SPAN CLASS="Argument">attrs_this_class</SPAN>, <SPAN CLASS="Argument">args_super</SPAN>, <SPAN CLASS="Argument">new_default={}</SPAN>, <SPAN CLASS="Argument">enforce_value={}</SPAN>, <SPAN CLASS="Argument">exclude_bases={}</SPAN>)<SPAN CLASS="OneLiner"> # Build an instance of a class.</SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.init_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.init_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)<SPAN CLASS="OneLiner"> # Initialises existing attributes</SPAN>

    <SPAN CLASS="InheritsHead"># Inherited from AppState.AppState</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.__getattr__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">name</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">app_name=None</SPAN>, <SPAN CLASS="Argument">translation_is_off=0</SPAN>, <SPAN CLASS="Argument">max_history=100</SPAN>, <SPAN CLASS="Argument">**attrs</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppState._new_source_buffer"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState._new_source_buffer</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppState.active_field"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.active_field</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # indicates what part of the editor has the focus.</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.active_language"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.active_language</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # Returns name of active programming language.</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.app_active_buffer_name"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.app_active_buffer_name</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppState.app_close_buffer"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.app_close_buffer</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>, <SPAN CLASS="Argument">save=0</SPAN>)<SPAN CLASS="OneLiner"> # Ask the editor to close a buffer.</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.app_save_file"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.app_save_file</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">full_path=None</SPAN>, <SPAN CLASS="Argument">no_prompt=0</SPAN>)<SPAN CLASS="OneLiner"> # Tell the external editor to save the current buffer.</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.apply_updates"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.apply_updates</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">updates</SPAN>)<SPAN CLASS="OneLiner"> # Applies a list of updates returned by the external application.</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.bidirectional_selection"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.bidirectional_selection</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # does editor support selections with cursor at left?</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.bind_to_buffer"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.bind_to_buffer</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)<SPAN CLASS="OneLiner"> # Binds the AppState to a particular buffer.</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.change_app_buffer"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.change_app_buffer</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)<SPAN CLASS="OneLiner"> # Changes the external application's active buffer.</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.change_buffer"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.change_buffer</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)<SPAN CLASS="OneLiner"> # Changes the active buffer.</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.close_all_buffers"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.close_all_buffers</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">save=0</SPAN>)<SPAN CLASS="OneLiner"> # Tell the editor to close all buffers known to VoiceCode</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.close_buffer"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.close_buffer</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>, <SPAN CLASS="Argument">save=0</SPAN>)<SPAN CLASS="OneLiner"> # close a buffer</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.close_buffer_cbk</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppState.curr_buffer"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.curr_buffer</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppState.curr_buffer_name"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.curr_buffer_name</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppState.drop_breadcrumb"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.drop_breadcrumb</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buffname=None</SPAN>, <SPAN CLASS="Argument">pos=None</SPAN>)<SPAN CLASS="OneLiner"> # Drops a breadcrumb</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.find_buff"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.find_buff</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name=None</SPAN>)<SPAN CLASS="OneLiner"> # Returns the open buffer with name <EM>STR buff_name</EM>.</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.focus_is_source"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.focus_is_source</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">lang_name</SPAN>)<SPAN CLASS="OneLiner"> # Check if prog. env. focus is a source buffer</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.get_history"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.get_history</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">nth</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppState.init_for_test"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.init_for_test</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppState.is_bound_to_buffer"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.is_bound_to_buffer</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # Returns the name of the buffer that AppState is currently bound to.</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.log_cmd"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.log_cmd</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">cont</SPAN>, <SPAN CLASS="Argument">action</SPAN>)<SPAN CLASS="OneLiner"> # Logs a command in the application's history</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.multiple_buffers"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.multiple_buffers</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # does editor support multiple open buffers?</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.new_compatible_sb"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.new_compatible_sb</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)<SPAN CLASS="OneLiner"> # Creates a new instance of [SourceBuff].</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.open_buffer_cbk"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.open_buffer_cbk</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppState.open_buffers_from_app"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.open_buffers_from_app</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppState.open_file"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.open_file</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">file_name</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppState.pop_breadcrumbs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.pop_breadcrumbs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">num=1</SPAN>, <SPAN CLASS="Argument">gothere=1</SPAN>)<SPAN CLASS="OneLiner"> # Pops breadcrumbs from the breadcrumbs stack</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.query_buffer_from_app"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.query_buffer_from_app</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppState.recog_begin"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.recog_begin</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">window_id</SPAN>)<SPAN CLASS="OneLiner"> # Invoked at the beginning of a recognition event.</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.recog_end"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.recog_end</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # Invoked at the end of a recognition event.</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.recog_indicator"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.recog_indicator</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">status</SPAN>)<SPAN CLASS="OneLiner"> # Sets a "recognition in progress" visual indicator.</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.rename_buffer_cbk"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.rename_buffer_cbk</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">old_buff_name</SPAN>, <SPAN CLASS="Argument">new_buff_name</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppState.save_file"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.save_file</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">full_path=None</SPAN>, <SPAN CLASS="Argument">no_prompt=0</SPAN>)<SPAN CLASS="OneLiner"> # Tell the external editor to save the current buffer.</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.synchronize_with_app"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.synchronize_with_app</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">what=[]</SPAN>, <SPAN CLASS="Argument">exclude=1</SPAN>, <SPAN CLASS="Argument">updates=None</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppState.tell_editor_to_open_file"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.tell_editor_to_open_file</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">file_name</SPAN>)<SPAN CLASS="OneLiner"> # Tell the editor to open a file in a new buffer.</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.unbind_from_buffer"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.unbind_from_buffer</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # unbinds the AppState from a particular buffer.</SPAN>
    <A CLASS="DocLink" HREF="#AppState.AppState.updates_from_app"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppState.updates_from_app</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">what=[]</SPAN>, <SPAN CLASS="Argument">exclude=1</SPAN>)<SPAN CLASS="OneLiner"> # Gets a list of updates from the external app.</SPAN>

</PRE><H2>Description</H2><P>
Interface optimised for editors that communicate with VoiceCode
through a slow link.</P>
<P>
In order to minimise communication between VoiceCode and the
editor, <EM>AppStateCached</EM> keeps a local copy of the state of the
editor. This avoids having to query the editor for the same
information all the time.</P>
<P>
Methods in <EM>AppStateCached</EM> assume that:</P>

<UL>

<LI>The cached information will be synchronised with the editor's
  state at the beginning of every utterance.
<LI><EM>AppStateCached</EM> methods that affect the state of the editor
  <EM>directly</EM> (that is, without going through an other [AppState]
  or [SourceBuff] method) will synchronize the cache before
  exiting.
</UL>
<P>
For any method <EM>readingMethod</EM> that reads the state of the
external editor, <EM>AppStateCached</EM> implements two methods:</P>

<DL>

<DT>
<EM>readingMethod</EM>
<DD>This is the public method (usually a method of
 [AppState]) used to read the state. It usually just checks if
 value is cached, and if so, reads it from cache. If value is not
 cached, it retrieves it from the external editor an caches it.
<DT>
<EM>_readingMethod_from_app</EM>
<DD>This is a private method which reads
 the state directly from the external editor. Such methods are not
 expected to save the read state to cache (this will done by
 [synchronize_with_app] method).
</DL>
<P>
For any method <EM>writingMethod</EM> that changes the state of the
external editor, <EM>AppStateCached</EM> implements two methods:</P>

<DL>

<DT>
<EM>writingMethod</EM>
<DD>This is the public method. It does the change
 on the external editor (i.e. invoke *_writingMethod_from_app*)
 and then synchronises the cache with the external editor.
<DT>
<EM>_writingMethod_from_app</EM>
<DD>This is a private method that just
 effects the change on the external editor, without synchronizing
 the cache.     
</DL>
<P>
<STRONG>INSTANCE ATTRIBUTES</STRONG></P>

<DL>

<DT>
{STR: STR} <EM>cache</EM>
<DD>Key is the name of a cached information
about the buffer, and value is the value of that information.
</DL>
<P>
CLASS ATTRIBUTES**</P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<P>
..[curr_buffer_name] AppStateCached.AppStateCached.html#curr_buffer_name
..[multiple_buffers] AppStateCached.AppStateCached.html#multiple_buffers
..[synchronize_with_app] AppStateCached.AppStateCached.html#synchronize_with_app
..[AppState] AppState.AppState.html
..[SourceBuff] SourceBuff.SourceBuff.html</P>
<H2 ID="AppStateCached.AppStateCached.init_cache" CLASS="Method">AppStateCached.AppStateCached.init_cache(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>Initialises the cache with data obtained from external editor.</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="Object.Object.decl_attrs" CLASS="Method">Object.Object.decl_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>Define new attributes for <EM>self</EM></P>

<P>
Attributes are directly through self.__dict__, thus bypassing safe
__setattr__.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 initial values as the values.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="Object.Object.deep_construct" CLASS="Method">Object.Object.deep_construct(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">this_class</SPAN>, <SPAN CLASS="Argument">attrs_this_class</SPAN>, <SPAN CLASS="Argument">args_super</SPAN>, <SPAN CLASS="Argument">new_default={}</SPAN>, <SPAN CLASS="Argument">enforce_value={}</SPAN>, <SPAN CLASS="Argument">exclude_bases={}</SPAN>)</H2>
<P>Build an instance of a class.</P>

<P>
Basically, this method:
- declares and initialise all attributes listed in <EM>attrs_this_class</EM>
- invokes the <EM>__init__</EM> of all superclasses (with the exclusion of those listed in *exclude_bases*), passing them arguments in <EM>args_super</EM></P>

<DL>

<DT>
<EM>CLASS</EM> this_class
<DD>Class that we want to build. This is a
 class object as opposed to the name of a class. Constructors
 of immediate superclasses of <EM>this_class</EM> are called
 automatically, except if they are listed in *{CLASS: 1}
 exclude_bases*.
<DT>
<EM>{STR: ANY}</EM> attrs_this_class
<DD>New attributes (and their
 values) defined by class <EM>this_class</EM>. The keys are the names
 of the attributes and the values are the values of the
 attributes (either default values or values passed to
 *this_class.__init__*). An attribute with the appropriate
 name will be declared automatically and initialsed to the
 value specified in <EM>attrs_this_class</EM>.
<DT>
<EM>{STR: ANY}</EM> args_super
<DD>Arguments received by
<EM>this_class.__init__</EM> but not recognised by it. These are
assumed to be arguments defined in the <EM>__init__</EM> of some
ancestor class and are just passed up the construction
chain. Keys of <EM>args_super</EM> correspond to the names of the
arguments and the values corresponds to the values received
for them by <EM>this_class.__init__</EM>
<DT>
<EM>{STR: ANY}</EM> new_default={}
<DD>Used to change the default
 value of an ancestor constructor argument. In other words, if
 <EM>this_class.__init__</EM> was called without specifying a value
 for an argument that's listed in <EM>new_default</EM>, the default
 value defined in <EM>new_default</EM> will be used instead of
 whatever default might be defined in the constructor
 of an ancestor class. However, if the constructor was called
 WITH a specific value for that argument, that specific value
 will be used instead of both the defaults defined in
 <EM>new_default</EM> and the constructor of ancestor classes. Keys
 of <EM>new_default</EM> correspond to argument names, and values
 correspond to the new default values. If you don't specify a
 value of <EM>new_default</EM>, it defaults to <EM>{}</EM>, which means that
 the defaults of none of the ancestor constructor arguments
 are redefined by <EM>this_class</EM>.
<DT>
<EM>{STR: ANY}</EM> enforce_value={}
<DD>Lists of arguments with
 enforced values. If the constructor is called with a value
 for an argument that is different from the value specified
 for it in <EM>enforce_value</EM>, then an <A HREF="Object.EnforcedConstrArg.html">EnforcedConstrArg</A>
 exception will be raised. Also, if the constructor is called
 without specifying a value for a particular argument, then
 the value defined in <EM>enforce_value</EM> (if it exists) will be
 used instead of whatever default might be defined in an
 ancestor class. Keys of <EM>enforce_value</EM> correspond to
 argument names and values correspond to the enforced
 values. If you don't specify a value for <EM>enforce_value</EM>, it
 defaults to <EM>{}</EM>, which means that <EM>this_class.__init__</EM> does
 not enforce the value of any argument.
<DT>
<EM>{CLASS: BOOL}</EM> exclude_bases
<DD>Immediate base classes whose
constructors should not be called automatically. If an
immediate superclass of <EM>this_class</EM> is listed in
<EM>exclude_bases</EM>, then we don't automatically call its
constructor. It is assumed that the programmer will call the
constructor manually in <EM>this_class.__init__</EM>. If you do not
specify a value for <EM>exclude_bases</EM>, it will default to <EM>{}</EM>,
which means that the constructor of all immediate super
classes will be called automatically.
</DL>
<H2 ID="Object.Object.init_attrs" CLASS="Method">Object.Object.init_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>Initialises existing attributes</P>

<P>
Attributes are only set if they already exist in
 <EM>self.__dict__</EM>. Otherwise, an <EM>AttributeError</EM> exception is
 raised (provided PY_DEBUG_OBJECT=1).</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 default values as the values.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="AppState.AppState._new_source_buffer" CLASS="Method">AppState.AppState._new_source_buffer(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)</H2>
<P>None</P>

<P>
Creates a new [SourceBuff] instances and adds it to the
list of open buffers.</P>
<P>
Note: this method should not only be called by other AppState
methods, not from outside AppState, and only if such methods
have already verified that self.open_buffers doesn't already
have a key matching buff_name</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
STR <EM>buff_name</EM>
<DD>unique name of the new buffer
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>SourceBuff</EM>
<DD>the new buffer
</DL>
<H2 ID="AppState.AppState.active_field" CLASS="Method">AppState.AppState.active_field(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>indicates what part of the editor has the focus.</P>

<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>(STR)</EM>
<DD>Name of the active Field. Elements of
the array refer to a sequence of objects in the user interface
that lead to the active field.
</DL>
<P>
If <EM>None</EM>, then the buffer [self.curr_buffer()] has the focus. </P>
<P>
Example: in VisualBasic, it might be: *('menu bar', <CODE>File</CODE>, 'Save
as', 'file name')*.</P>
<P>
Example: in Emacs, it might be <EM>('find-buffer', 'buffer-name')</EM>
where find-buffer is the name of the command that was invoked and
buffer-name refers to the argument that is being asked for.
</P>
<H2 ID="AppState.AppState.active_language" CLASS="Method">AppState.AppState.active_language(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>Returns name of active programming language.</P>

<P>
If no active programming language, then returns <EM>None</EM>.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> language
<DD>Name of active programming language (*None*
if no programming language is active).

</DL>
<H2 ID="AppState.AppState.app_active_buffer_name" CLASS="Method">AppState.AppState.app_active_buffer_name(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
Returns the file name of the buffer currently active in the
external application.</P>
<P>
Note that this may or may not be the same the buffer that
VoiceCode is currently bound to (see [curr_buffer_name]
method for a description of buffer binding).</P>
<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM> --</P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM>
<DD>file name of current buffer
</DL>
<P>
AppState.AppState.html#curr_buffer_name</P>
<H2 ID="AppState.AppState.app_close_buffer" CLASS="Method">AppState.AppState.app_close_buffer(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>, <SPAN CLASS="Argument">save=0</SPAN>)</H2>
<P>Ask the editor to close a buffer.</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
STR <EM>buff_name</EM>
<DD>name of buffer to close
<DT>
INT <EM>save</EM>
<DD><EM>-1</EM> -&gt; don't save the buffer
                    <EM>0</EM> -&gt; query user if buffer needs saving
                    <EM>1</EM> -&gt; save without querying user
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if the editor does close the buffer

</DL>
<H2 ID="AppState.AppState.app_save_file" CLASS="Method">AppState.AppState.app_save_file(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">full_path=None</SPAN>, <SPAN CLASS="Argument">no_prompt=0</SPAN>)</H2>
<P>Tell the external editor to save the current buffer.</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR full_path</EM>
<DD>full path under which to save the file, or
None to use the buffer name
<DT>
<EM>BOOL no_prompt</EM>
<DD>overwrite any existing file without
prompting.  No_prompt should only be set to true if the caller
has already prompted the user.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM>
<DD>new buffer name if successful, or None if the save 
failed

</DL>
<H2 ID="AppState.AppState.apply_updates" CLASS="Method">AppState.AppState.apply_updates(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">updates</SPAN>)</H2>
<P>Applies a list of updates returned by the external application.</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
[ [AS_Updates] ] <EM>updates</EM>
<DD>List of updates
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<P>
..[AS_Updates] AppState.AS_Updates.html</P>
<H2 ID="AppState.AppState.bidirectional_selection" CLASS="Method">AppState.AppState.bidirectional_selection(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>does editor support selections with cursor at left?</P>

<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if editor allows setting the selection at the
left end of the selection
</DL>
<H2 ID="AppState.AppState.bind_to_buffer" CLASS="Method">AppState.AppState.bind_to_buffer(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)</H2>
<P>Binds the AppState to a particular buffer.</P>

<P>
See [curr_buffer_name] for a description of buffer binding.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
STR <EM>buff_name</EM>
<DD>Name of the buffer to bind to.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if buffer exists and AppState can be bound to it
</DL>
<P>
..[curr_buffer_name] AppState.AppState.html#curr_buffer_name</P>
<H2 ID="AppState.AppState.change_app_buffer" CLASS="Method">AppState.AppState.change_app_buffer(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)</H2>
<P>Changes the external application's active buffer.</P>

<P>
This variant only changes the buffer in the external
application. It does not resynchronise VoiceCode with external
application.</P>
<P>
This should NOT bind the <EM>AppState</EM> to the new buffer. This
should be done only by [change_buffer].</P>
<P>
See [curr_buffer_name] for a description of buffer binding.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
STR <EM>buff_name</EM>
<DD>Name of the buffer to switch to.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if buff_name exists and the external application
successfully switches to it
</DL>
<P>
AppState.AppState.html#curr_buffer_name</P>
<H2 ID="AppState.AppState.change_buffer" CLASS="Method">AppState.AppState.change_buffer(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)</H2>
<P>Changes the active buffer.</P>

<P>
Will also bind the AppState to that buffer if the application is
currently bound to a buffer.
See [curr_buffer_name] for a description of
buffer binding.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
STR <EM>buff_name</EM>
<DD>Name of the buffer to switch to.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if buff_name exists and the external application
successfully switches to it
</DL>
<P>
AppState.AppState.html#curr_buffer_name</P>
<H2 ID="AppState.AppState.close_all_buffers" CLASS="Method">AppState.AppState.close_all_buffers(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">save=0</SPAN>)</H2>
<P>Tell the editor to close all buffers known to VoiceCode</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
INT <EM>save</EM>
<DD><EM>-1</EM> -&gt; don't save the buffer
                    <EM>0</EM> -&gt; query user if buffer needs saving
                    <EM>1</EM> -&gt; save without querying user
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="AppState.AppState.close_buffer" CLASS="Method">AppState.AppState.close_buffer(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>, <SPAN CLASS="Argument">save=0</SPAN>)</H2>
<P>close a buffer</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
STR <EM>buff_name</EM>
<DD>name of buffer to close
<DT>
INT <EM>save</EM>
<DD><EM>-1</EM> -&gt; don't save the buffer
                    <EM>0</EM> -&gt; query user if buffer needs saving
                    <EM>1</EM> -&gt; save without querying user
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if the editor does close the buffer

</DL>
<H2 ID="AppState.AppState.curr_buffer" CLASS="Method">AppState.AppState.curr_buffer(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
Returns the SourceBuff corresponding to the default editor buffer,
or the current buffer if the default is not set</P>
<P>
If no such buffer, returns <EM>None</EM>.</P>
<H2 ID="AppState.AppState.curr_buffer_name" CLASS="Method">AppState.AppState.curr_buffer_name(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
Returns the file name of the buffer that VoiceCode
currently operates on.</P>
<P>
This may or may not be the same as the active buffer in the
editor (this is returned by method [app_active_buffer_name]).</P>
<P>
When interpreting an utterance, VoiceCode binds the <EM>AppState</EM> to the
buffer that was active in the editor at the moment when the
utterance started. This is so that the utterance will always
go to that buffer, even if the user clicks on a different
buffer while the utterance is still being processed.</P>
<P>
Note however that if the user utters a command that switches
the active buffer in mid-utterance, VoiceCode will then bind
the <EM>AppState</EM> to that new buffer so that the rest of the utterance
goes there.</P>
<P>
WARNING: DO NOT OVERRIDE THIS METHOD UNLESS YOU KNOW WHAT YOU
ARE DOING!!!</P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM>
<DD>file name of current buffer
</DL>
<P>
AppState.AppState.html#app_active_buffer_name</P>
<H2 ID="AppState.AppState.drop_breadcrumb" CLASS="Method">AppState.AppState.drop_breadcrumb(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buffname=None</SPAN>, <SPAN CLASS="Argument">pos=None</SPAN>)</H2>
<P>Drops a breadcrumb</P>

<P>
<EM>INT pos</EM> is the position where to drop the crumb. *STR
 buffname* is the name of the source buffer.</P>
<P>
If <EM>pos</EM> not specified, drop breadcrumb at cursor position.</P>
<P>
If <EM>buff</EM> not specified either, drop breadcrumb in current buffer
</P>
<H2 ID="AppState.AppState.find_buff" CLASS="Method">AppState.AppState.find_buff(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name=None</SPAN>)</H2>
<P>Returns the open buffer with name <EM>STR buff_name</EM>.</P>

<P>
If no such buffer, returns <EM>None</EM>.</P>
<P>
If <EM>buff_name</EM> is <EM>None</EM>, return <A HREF="AppState.AppState.html">self.curr_buffer</A>.</P>
<H2 ID="AppState.AppState.focus_is_source" CLASS="Method">AppState.AppState.focus_is_source(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">lang_name</SPAN>)</H2>
<P>Check if prog. env. focus is a source buffer</P>

<P>
Returns <EM>true</EM> if and only if focus of programming environment
is a source buffer written in language <EM>STR lang_name</EM>.
</P>
<H2 ID="AppState.AppState.get_history" CLASS="Method">AppState.AppState.get_history(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">nth</SPAN>)</H2>
<P>None</P>

<P>
Gets the <EM>nth</EM> most recent entry in the application's command
history</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>INT</EM> nth
<DD>Index of the requested entry (from the end)
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>(</EM> <A HREF="Context.Context.html">Context</A>, <A HREF="Action.Action.html">Action</A> <EM>)</EM> hist_entry
<DD>The context and action of the <EM>nth</EM> most
recent command in the application's command history.
</DL>
<H2 ID="AppState.AppState.init_for_test" CLASS="Method">AppState.AppState.init_for_test(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
Reinitialise the <EM>AppState</EM> so that it is ready for a new
regression test.</P>
<P>
When running several regression tests using the same
<EM>AppState</EM> (for example, an <EM>AppState</EM> connected to an
external editor), we need to reinitialise it after every test.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="AppState.AppState.is_bound_to_buffer" CLASS="Method">AppState.AppState.is_bound_to_buffer(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>Returns the name of the buffer that AppState is currently bound to.</P>

<P>
See [curr_buffer_name] for a description of buffer binding.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<P>
..[curr_buffer_name] AppState.AppState.html#curr_buffer_name</P>
<H2 ID="AppState.AppState.log_cmd" CLASS="Method">AppState.AppState.log_cmd(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">cont</SPAN>, <SPAN CLASS="Argument">action</SPAN>)</H2>
<P>Logs a command in the application's history</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
[Context] cont
<DD>Context in which the command was invoked.
<DT>
[Action] action
<DD>Action that was executed in response to the command
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="AppState.AppState.multiple_buffers" CLASS="Method">AppState.AppState.multiple_buffers(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>does editor support multiple open buffers?</P>

<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if editor supports having multiple buffers open 
at the same time
</DL>
<H2 ID="AppState.AppState.new_compatible_sb" CLASS="Method">AppState.AppState.new_compatible_sb(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)</H2>
<P>Creates a new instance of [SourceBuff].</P>

<P>
Note: The class used to instantiate the [SourceBuff] needs to
be compatible with the class of <EM>self</EM>. With a few exceptions
(if any), each subclass of <EM>AppState</EM> will have to redefine
<EM>new_compatible_sb</EM> in order to generate a [SourceBuff] of the
appropriate class.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
STR <EM>buff_name</EM>
<DD>unique name for the source buffer.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>SourceBuff</EM>
<DD>the new buffer
</DL>
<P>
..[SourceBuff] SourceBuff.SourceBuff.html</P>
<H2 ID="AppState.AppState.open_buffer_cbk" CLASS="Method">AppState.AppState.open_buffer_cbk(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)</H2>
<P>None</P>

<P>
Editor invokes this method to notify VoiceCode that it
opened a new text buffer.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
STR <EM>buff_name</EM>
<DD>unique name of the buffer.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
..[SourceBuff] SourceBuff.SourceBuff.html</P>
<H2 ID="AppState.AppState.open_buffers_from_app" CLASS="Method">AppState.AppState.open_buffers_from_app(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
retrieve a list of the names of open buffers from the
application.</P>
<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>[STR]</EM>
<DD>list of the names of open buffers

</DL>
<H2 ID="AppState.AppState.open_file" CLASS="Method">AppState.AppState.open_file(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">file_name</SPAN>)</H2>
<P>None</P>

<P>
Tell the external editor to open a file, and create a local buffer
for that file.</P>
<P>
Open file with name <EM>STR name</EM>.</P>
<P>
Right now, this is used mostly so that the regression testing
procedure can tell the external editor to open a test
file. But in the future, it may be used to voice-enable the
open-file dialogue using pseudo-code dictation of file names.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
STR <EM>file_name</EM>
<DD>Full path of the file to be opened.
</DL>
<H2 ID="AppState.AppState.pop_breadcrumbs" CLASS="Method">AppState.AppState.pop_breadcrumbs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">num=1</SPAN>, <SPAN CLASS="Argument">gothere=1</SPAN>)</H2>
<P>Pops breadcrumbs from the breadcrumbs stack</P>

<P>
<EM>INT num</EM> is the number of crumbs to pop. If None, then pop 1 crumb.</P>
<P>
if <EM>BOOL gothere</EM> is true, then move cursor to the last popped
breadcrumb.
</P>
<H2 ID="AppState.AppState.query_buffer_from_app" CLASS="Method">AppState.AppState.query_buffer_from_app(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)</H2>
<P>None</P>

<P>
query the application to see if a buffer by the name of buff_name 
exists.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> buff_name
<DD>name of the buffer to check
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>does the buffer exist?

</DL>
<H2 ID="AppState.AppState.recog_begin" CLASS="Method">AppState.AppState.recog_begin(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">window_id</SPAN>)</H2>
<P>Invoked at the beginning of a recognition event.</P>

<P>
The editor then returns telling VoiceCode whether or not the user
is allowed to speak into window <EM>window_id</EM>.</P>
<P>
If possible, the editor should also stop responding to user
input until method <A HREF="AppState.AppState.html#recog_end">recog_end()</A> is invoked. This is to
prevent a bunch of problems that can arise if the user types
while VoiceCode is still processing an utterance. In such
cases, the results of the utterance interpretation can be
unpredictable, especially when it comes to correction.</P>
<P>
Each external editor will respond to that message as best it can.</P>
<P>
Ideally, the editor would:</P>

<UL>

<LI>Start recording user actions to a log

<LI>execute those actions later when <A HREF="AppState.AppState.html#recog_end">recog_end()</A> is invoked.
</UL>
<P>
If the editor is able to stop responding to user input, but is
not able to record them and/or execute them later, then it
should:</P>

<UL>

<LI>Stop responding to user input until <A HREF="AppState.AppState.html#recog_end">recog_end()</A> is
  later invoked.
</UL>
<P>
If the editor is not even able to stop responding to user
input, then it should:</P>

<UL>

<LI>Do nothing
</UL>
<P>
NOTE: This method may be invoked more than once before
<A HREF="AppState.AppState.html#recog_end">recog_end()</A> is invoked. In such cases, only the first
call to the method should do anything.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
STR <EM>window_id</EM>
<DD>The ID of the window that was active when
the recognition began.                
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
BOOL <EM>can_talk</EM>
<DD><EM>true</EM> iif editor allows user to speak into window
with ID <EM>window_id</EM>
</DL>
<H2 ID="AppState.AppState.recog_end" CLASS="Method">AppState.AppState.recog_end(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>Invoked at the end of a recognition event.</P>

<P>
This tells the editor to start responding to user
input again, and possibly to execute any user inputs it may
have recorded since [recog_begin()] was invoked.</P>
<P>
Each external editor will respond to that message as best it can.</P>
<P>
Ideally, the editor would:</P>

<UL>

<LI>Execute all actions that were logged
<LI>Stop recording user actions to a log, and execute them as
  they arrrive instead.
</UL>
<P>
If the editor is able to stop responding to user input, but is
not able to record them and/or execute them later, then it
should:</P>

<UL>

<LI>Start responding to user input again
</UL>
<P>
If the editor is not even able to stop responding to user
input, then it should:</P>

<UL>

<LI>Do nothing
</UL>
<P>
NOTE: This method may be invoked more than once before
[recog_begin()] is invoked. In such cases, only the first
call to the method should do anything.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<P>
..[recog_begin()] AppState.AppState.html#recog_begin</P>
<H2 ID="AppState.AppState.recog_indicator" CLASS="Method">AppState.AppState.recog_indicator(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">status</SPAN>)</H2>
<P>Sets a "recognition in progress" visual indicator.</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
STR <EM>status</EM>
<DD><CODE>on</CODE> or <CODE>off</CODE>
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="AppState.AppState.rename_buffer_cbk" CLASS="Method">AppState.AppState.rename_buffer_cbk(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">old_buff_name</SPAN>, <SPAN CLASS="Argument">new_buff_name</SPAN>)</H2>
<P>None</P>

<P>
Editor invokes this method to notify VoiceCode that it
has renamed an existing text buffer.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
STR <EM>old_buff_name</EM>
<DD>old name of the buffer.
<DT>
STR <EM>new_buff_name</EM>
<DD>new name of the buffer.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
..[SourceBuff] SourceBuff.SourceBuff.html</P>
<H2 ID="AppState.AppState.save_file" CLASS="Method">AppState.AppState.save_file(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">full_path=None</SPAN>, <SPAN CLASS="Argument">no_prompt=0</SPAN>)</H2>
<P>Tell the external editor to save the current buffer.</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR full_path</EM>
<DD>full path under which to save the file, or
None to use the buffer name
<DT>
<EM>BOOL no_prompt</EM>
<DD>overwrite any existing file without
prompting.  No_prompt should only be set to true if the caller
has already prompted the user.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if file was saved successfully

</DL>
<H2 ID="AppState.AppState.synchronize_with_app" CLASS="Method">AppState.AppState.synchronize_with_app(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">what=[]</SPAN>, <SPAN CLASS="Argument">exclude=1</SPAN>, <SPAN CLASS="Argument">updates=None</SPAN>)</H2>
<P>None</P>

<P>
Make sure that VoiceCode is in sync with the state of the
external editor.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
[STR] <EM>what=[]</EM>
<DD>List of what is to be synchronised. Valid
entries are: <CODE>buff_name</CODE>, <CODE>content</CODE>, <CODE>cur_pos</CODE>, <CODE>selection</CODE>.
<EM>exclude=1</EM>, this should be interpreted as a list of items that
don't need to be synchronised. If <EM>exclude=0</EM>, then it should be
interpreted as a list of items that need to be syncrhonized.
<DT>
[ [AS_Update] ] updates
<DD>Updates to be applied in the
synchronisation. If <EM>None</EM>, get updates from the external
editor.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="AppState.AppState.tell_editor_to_open_file" CLASS="Method">AppState.AppState.tell_editor_to_open_file(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">file_name</SPAN>)</H2>
<P>Tell the editor to open a file in a new buffer.</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
STR <EM>file_name</EM>
<DD>The full path of the file to be opened.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
STR <EM>buff_name</EM>
<DD>Unique name of the buffer in which the file
was opened. Returns <EM>None</EM> if the editor was not able to open
the file.
</DL>
<H2 ID="AppState.AppState.unbind_from_buffer" CLASS="Method">AppState.AppState.unbind_from_buffer(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>unbinds the AppState from a particular buffer.</P>

<P>
See [curr_buffer_name] for a description of buffer binding.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<P>
..[curr_buffer_name] AppState.AppState.html#curr_buffer_name</P>
<H2 ID="AppState.AppState.updates_from_app" CLASS="Method">AppState.AppState.updates_from_app(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">what=[]</SPAN>, <SPAN CLASS="Argument">exclude=1</SPAN>)</H2>
<P>Gets a list of updates from the external app.</P>

<P>
Note: the list of updates must ALWAYS include the name of the
external app's active buffer.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
[STR] <EM>what</EM>
<DD>List of items to be included/excluded in the updates.
<DT>
BOOL <EM>exclude</EM>
<DD>Indicates if <EM>what</EM> is a list of items to be
included or excluded from updates.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
[ [AS_Update] ] <EM>updates</EM>
<DD>List of updates retrieved from the
external app.
</DL>
<P>
..[AS_Update] AppState.AS_Update.html</P>

<HR>
<TABLE ALIGN="LEFT">
<TR><TD>
  <A HREF="http://validator.w3.org/check/referer" TARGET="validate">
    <IMG BORDER=0 SRC="http://validator.w3.org/images/vh40.gif"
     ALT="Valid HTML 4.0!" HEIGHT=31 WIDTH=88></A>
  <A HREF="http://www.w3.org/Style/CSS/Buttons">
    <IMG ALT="Made with CSS" BORDER=0 WIDTH=88 HEIGHT=31 
     SRC="http://www.w3.org/Style/CSS/Buttons/mwcos"></A>

</TD>
<TD STYLE="padding-left: 10">
  <SPAN CLASS="AUTHOR"></SPAN><BR>
  <SPAN CLASS="VERSION"></SPAN>
</TD>
</TABLE>

</body>
</html>
