<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>

<head>

<META NAME="GENERATOR" CONTENT="pythondoc 0.7 (Fri Sep 29 10:16:36 2000)">

<link rel="stylesheet" href="pythondoc.css" type="text/css">

<title>Class SymDict</title>
</head>

<body>
<P><A HREF="index.html">Table of contents</A> <A HREF="indices.html">Index</A></P>


<H1 CLASS="ClassName">class SymDict - Symbol dictionary.</H1>
<P CLASS="DeclaredIn">Declared in module <A HREF="SymDict.html">SymDict</A></P>

<H2 CLASS="ClassHierarchy">Inheritance hierarchy:</H2><P CLASS="ClassHierarchy">SymDict.SymDict<BR>
&nbsp;&nbsp;Object.Object<BR>
</P>

<H2>Synopsis</H2>
<PRE CLASS="ClassDeclaration">
<SPAN CLASS="PyKeyword">class</SPAN> <SPAN CLASS="ClassName">SymDict</SPAN>(<A CLASS="DocLink" HREF="Object.Object.html">Object</A>):
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SymDict.SymDict.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">symbol_info={}</SPAN>, <SPAN CLASS="Argument">spoken_form_info={}</SPAN>, <SPAN CLASS="Argument">abbreviations={}</SPAN>, <SPAN CLASS="Argument">**attrs</SPAN>)
    <A CLASS="DocLink" HREF="#SymDict.SymDict.add_symbol"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SymDict.SymDict.add_symbol</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">symbol</SPAN>)<SPAN CLASS="OneLiner"> # Add a symbol to the dictionary</SPAN>
    <A CLASS="DocLink" HREF="#SymDict.SymDict.compilation_test"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SymDict.SymDict.compilation_test</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">source</SPAN>)
    <A CLASS="DocLink" HREF="#SymDict.SymDict.expand_possible_forms"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SymDict.SymDict.expand_possible_forms</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">partial_forms</SPAN>, <SPAN CLASS="Argument">further_extensions</SPAN>)<SPAN CLASS="OneLiner"> # Returns a list of possible spoken forms for a symbol.</SPAN>
    <A CLASS="DocLink" HREF="#SymDict.SymDict.expand_word"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SymDict.SymDict.expand_word</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">word</SPAN>, <SPAN CLASS="Argument">symbol</SPAN>)<SPAN CLASS="OneLiner"> # Expands a word from a symbol to its possible spoken forms.</SPAN>
    <A CLASS="DocLink" HREF="#SymDict.SymDict.get_language_definition"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SymDict.SymDict.get_language_definition</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">file_name</SPAN>)<SPAN CLASS="OneLiner"> # Gets the definition of the language associated with a source file.</SPAN>
    <A CLASS="DocLink" HREF="#SymDict.SymDict.get_spoken_forms"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SymDict.SymDict.get_spoken_forms</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">symbol</SPAN>)<SPAN CLASS="OneLiner"> # Returns a list of possible spoken forms for a symbol.</SPAN>
    <A CLASS="DocLink" HREF="#SymDict.SymDict.parse_symbols"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SymDict.SymDict.parse_symbols</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">file_name</SPAN>)<SPAN CLASS="OneLiner"> # Parse symbols from a source file.</SPAN>
    <A CLASS="DocLink" HREF="#SymDict.SymDict.print_symbols"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SymDict.SymDict.print_symbols</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # Print the content of the symbol dictionary.</SPAN>
    <A CLASS="DocLink" HREF="#SymDict.SymDict.strip_source"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SymDict.SymDict.strip_source</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">source</SPAN>, <SPAN CLASS="Argument">language_definition</SPAN>)<SPAN CLASS="OneLiner"> # Removes all parts of a source file that don't contain symbols.</SPAN>
    <A CLASS="DocLink" HREF="#SymDict.SymDict.vocabulary_cleanup"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">SymDict.SymDict.vocabulary_cleanup</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # Removes symbols from the speech recognition vocabulary</SPAN>

    <SPAN CLASS="InheritsHead"># Inherited from Object.Object</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">**args_super</SPAN>)
    <A CLASS="DocLink" HREF="#Object.Object.decl_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.decl_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)<SPAN CLASS="OneLiner"> # Define new attributes for <EM>self</EM></SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.deep_construct"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.deep_construct</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">this_class</SPAN>, <SPAN CLASS="Argument">attrs_this_class</SPAN>, <SPAN CLASS="Argument">args_super</SPAN>, <SPAN CLASS="Argument">new_default={}</SPAN>, <SPAN CLASS="Argument">enforce_value={}</SPAN>, <SPAN CLASS="Argument">exclude_bases={}</SPAN>)<SPAN CLASS="OneLiner"> # Build an instance of a class.</SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.init_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.init_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)<SPAN CLASS="OneLiner"> # Initialises existing attributes</SPAN>

</PRE><H2>Description</H2><P>
This class stores information about symbols defined in source files
that the user is working on.</P>
<P>
It has methods for parsing symbols and adding pronounceable
phrases for those symbols to the Speech Recognition system's vocabulary.</P>
<P>
<STRONG>INSTANCE ATTRIBUTES</STRONG></P>

<DL>

<DT>
<EM>{STR:</EM> <A HREF="SymDict.SymbolInfo.html">SymbolInfo</A> <EM>)}</EM> symbol_info={}
<DD>The key is the symbol and
 the value is the information about that symbol.
<DT>
<EM>{STR:</EM> <A HREF="SymDict.SpokenFormInfo.html">SpokenFormInfo</A> <EM>}</EM> spoken_form_info={}
<DD>The key is a
 spoken form and the value is the list of symbols with that spoken
 form.
<DT>
<EM>{STR: [STR]}</EM> abbreviations={}
<DD>Dictionary of abbreviations. The
 key is the abbreviation and the value is a list of poosible expansions.
<DT>
<EM>{STR: None}</EM> unresolved_abbreviations={}
<DD>Dictionary of
 unresolved abbreviations. These are abbreviations that have
 appeared in at least one compiled symbol, yet are neither a word
 in the speech vocabulary or a known abbreviation.
</DL>
<P>
CLASS ATTRIBUTES**</P>

<DL>

<DT>
*{STR: * <A HREF="LangDef.LangDef.html">LangDef</A> <EM>}</EM> language_definitions={}
<DD>Key is the name
 of a language and the value is a language definition object which
 defines rules for parsing symbols in that language.
</DL>
<H2 ID="SymDict.SymDict.add_symbol" CLASS="Method">SymDict.SymDict.add_symbol(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">symbol</SPAN>)</H2>
<P>Add a symbol to the dictionary</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> symbol
<DD>Symbol to add 
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="SymDict.SymDict.compilation_test" CLASS="Method">SymDict.SymDict.compilation_test(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">source</SPAN>)</H2>
<P>None</P>

<P>
Does a compilation test on file <EM>source</EM>        
</P>
<H2 ID="SymDict.SymDict.expand_possible_forms" CLASS="Method">SymDict.SymDict.expand_possible_forms(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">partial_forms</SPAN>, <SPAN CLASS="Argument">further_extensions</SPAN>)</H2>
<P>Returns a list of possible spoken forms for a symbol.</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>[STR]</EM> partial_forms
<DD>a list of partially completed spoken
 forms. 
<DT>
<EM>[[STR]]</EM> further_extensions
<DD>a list of possibilities for
 further extending the spoken forms in <EM>partal_forms</EM>.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>[STR]</EM>
<DD>List of all possible spoken forms for the symbol.
</DL>
<H2 ID="SymDict.SymDict.expand_word" CLASS="Method">SymDict.SymDict.expand_word(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">word</SPAN>, <SPAN CLASS="Argument">symbol</SPAN>)</H2>
<P>Expands a word from a symbol to its possible spoken forms.</P>

<P>
If <EM>word</EM> is an in-vocabulary word simply returns <EM>[word]</EM></P>
<P>
If it's a known abbreviation returns the list of possible expansions
for that abbreviation or the list of their plural forms.</P>
<P>
If it's the plural of a known abbreviation, returns the plural
form of the abbreviation's expansions.</P>
<P>
Otherwise, it tries to split <EM>word</EM> into substrings that are
in-vocabulary words or known abbreviations (*NOT IMPLEMENTED
AT THE MOMENT).</P>
<P>
If that doesn't work either logs <EM>word</EM> in
<EM>self.unresolved_abbreviations</EM> and log <EM>symbol</EM> as one of the symbol
where it occured.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> abbreviation
<DD>Abbreviation to be expanded 
<DT>
<EM>STR</EM> symbol
<DD>Symbol in which the word appeared
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
*[STR] expansions *
<DD>list of possible expansions of the word.

</DL>
<H2 ID="SymDict.SymDict.get_language_definition" CLASS="Method">SymDict.SymDict.get_language_definition(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">file_name</SPAN>)</H2>
<P>Gets the definition of the language associated with a source file.</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> file_name
<DD>name of the file 
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
[LangDef]
<DD>definition of the language <EM>file_name</EM> is written
in. Returns <EM>None</EM> if there doesn't exist a proper language
definition, or if can't tell what language the source file is
written in.
</DL>
<P>
..[LangDef] LangDef.LangDef.html</P>
<H2 ID="SymDict.SymDict.get_spoken_forms" CLASS="Method">SymDict.SymDict.get_spoken_forms(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">symbol</SPAN>)</H2>
<P>Returns a list of possible spoken forms for a symbol.</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> symbol
<DD>the symbol in question 
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>[STR]</EM>
<DD>returns a list of spoken forms

</DL>
<H2 ID="SymDict.SymDict.parse_symbols" CLASS="Method">SymDict.SymDict.parse_symbols(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">file_name</SPAN>)</H2>
<P>Parse symbols from a source file.</P>

<P>
<EM>STR file_name</EM> is the path of the file.</P>
<P>
Parsed symbols are stored in the <EM>symbol_info</EM> and
<EM>spoken_forms2symbol</EM> attributes.
</P>
<H2 ID="SymDict.SymDict.print_symbols" CLASS="Method">SymDict.SymDict.print_symbols(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>Print the content of the symbol dictionary.</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="SymDict.SymDict.strip_source" CLASS="Method">SymDict.SymDict.strip_source(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">source</SPAN>, <SPAN CLASS="Argument">language_definition</SPAN>)</H2>
<P>Removes all parts of a source file that don't contain symbols.</P>

<P>
This includes comments and quoted strings.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> source
<DD>the source
<DT>
<A HREF="LangDef.LangDef.html">LangDef</A> language_definition
<DD>the definition of the
language that <EM>source</EM> is written in.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> stripped_source
<DD>source stripped of all non-symbols chunks
</DL>
<H2 ID="SymDict.SymDict.vocabulary_cleanup" CLASS="Method">SymDict.SymDict.vocabulary_cleanup(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>Removes symbols from the speech recognition vocabulary</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="Object.Object.decl_attrs" CLASS="Method">Object.Object.decl_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>Define new attributes for <EM>self</EM></P>

<P>
Attributes are directly through self.__dict__, thus bypassing safe
__setattr__.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 initial values as the values.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="Object.Object.deep_construct" CLASS="Method">Object.Object.deep_construct(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">this_class</SPAN>, <SPAN CLASS="Argument">attrs_this_class</SPAN>, <SPAN CLASS="Argument">args_super</SPAN>, <SPAN CLASS="Argument">new_default={}</SPAN>, <SPAN CLASS="Argument">enforce_value={}</SPAN>, <SPAN CLASS="Argument">exclude_bases={}</SPAN>)</H2>
<P>Build an instance of a class.</P>

<P>
Basically, this method:
- declares and initialise all attributes listed in <EM>attrs_this_class</EM>
- invokes the <EM>__init__</EM> of all superclasses (with the exclusion of those listed in *exclude_bases*), passing them arguments in <EM>args_super</EM></P>

<DL>

<DT>
<EM>CLASS</EM> this_class
<DD>Class that we want to build. This is a
 class object as opposed to the name of a class. Constructors
 of immediate superclasses of <EM>this_class</EM> are called
 automatically, except if they are listed in *{CLASS: 1}
 exclude_bases*.
<DT>
<EM>{STR: ANY}</EM> attrs_this_class
<DD>New attributes (and their
 values) defined by class <EM>this_class</EM>. The keys are the names
 of the attributes and the values are the values of the
 attributes (either default values or values passed to
 *this_class.__init__*). An attribute with the appropriate
 name will be declared automatically and initialsed to the
 value specified in <EM>attrs_this_class</EM>.
<DT>
<EM>{STR: ANY}</EM> args_super
<DD>Arguments received by
<EM>this_class.__init__</EM> but not recognised by it. These are
assumed to be arguments defined in the <EM>__init__</EM> of some
ancestor class and are just passed up the construction
chain. Keys of <EM>args_super</EM> correspond to the names of the
arguments and the values corresponds to the values received
for them by <EM>this_class.__init__</EM>
<DT>
<EM>{STR: ANY}</EM> new_default={}
<DD>Used to change the default
 value of an ancestor constructor argument. In other words, if
 <EM>this_class.__init__</EM> was called without specifying a value
 for an argument that's listed in <EM>new_default</EM>, the default
 value defined in <EM>new_default</EM> will be used instead of
 whatever default might be defined in the constructor
 of an ancestor class. However, if the constructor was called
 WITH a specific value for that argument, that specific value
 will be used instead of both the defaults defined in
 <EM>new_default</EM> and the constructor of ancestor classes. Keys
 of <EM>new_default</EM> correspond to argument names, and values
 correspond to the new default values. If you don't specify a
 value of <EM>new_default</EM>, it defaults to <EM>{}</EM>, which means that
 the defaults of none of the ancestor constructor arguments
 are redefined by <EM>this_class</EM>.
<DT>
<EM>{STR: ANY}</EM> enforce_value={}
<DD>Lists of arguments with
 enforced values. If the constructor is called with a value
 for an argument that is different from the value specified
 for it in <EM>enforce_value</EM>, then an <A HREF="Object.EnforcedConstrArg.html">EnforcedConstrArg</A>
 exception will be raised. Also, if the constructor is called
 without specifying a value for a particular argument, then
 the value defined in <EM>enforce_value</EM> (if it exists) will be
 used instead of whatever default might be defined in an
 ancestor class. Keys of <EM>enforce_value</EM> correspond to
 argument names and values correspond to the enforced
 values. If you don't specify a value for <EM>enforce_value</EM>, it
 defaults to <EM>{}</EM>, which means that <EM>this_class.__init__</EM> does
 not enforce the value of any argument.
<DT>
<EM>{CLASS: BOOL}</EM> exclude_bases
<DD>Immediate base classes whose
constructors should not be called automatically. If an
immediate superclass of <EM>this_class</EM> is listed in
<EM>exclude_bases</EM>, then we don't automatically call its
constructor. It is assumed that the programmer will call the
constructor manually in <EM>this_class.__init__</EM>. If you do not
specify a value for <EM>exclude_bases</EM>, it will default to <EM>{}</EM>,
which means that the constructor of all immediate super
classes will be called automatically.
</DL>
<H2 ID="Object.Object.init_attrs" CLASS="Method">Object.Object.init_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>Initialises existing attributes</P>

<P>
Attributes are only set if they already exist in
 <EM>self.__dict__</EM>. Otherwise, an <EM>AttributeError</EM> exception is
 raised (provided PY_DEBUG_OBJECT=1).</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 default values as the values.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>

<HR>
<TABLE ALIGN="LEFT">
<TR><TD>
  <A HREF="http://validator.w3.org/check/referer" TARGET="validate">
    <IMG BORDER=0 SRC="http://validator.w3.org/images/vh40.gif"
     ALT="Valid HTML 4.0!" HEIGHT=31 WIDTH=88></A>
  <A HREF="http://www.w3.org/Style/CSS/Buttons">
    <IMG ALT="Made with CSS" BORDER=0 WIDTH=88 HEIGHT=31 
     SRC="http://www.w3.org/Style/CSS/Buttons/mwcos"></A>

</TD>
<TD STYLE="padding-left: 10">
  <SPAN CLASS="AUTHOR"></SPAN><BR>
  <SPAN CLASS="VERSION"></SPAN>
</TD>
</TABLE>

</body>
</html>
